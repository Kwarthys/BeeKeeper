\chapter{Modélisation et Implémentation pour la Colonie d'Abeilles}

	Nous allons désormais voir ensemble l'implémentation du modèle que nous venons de décrire, appliqué au cas qui nous intéresse ici : la colonie d'abeilles. Pour une première itération, nos abeilles auront pour objectif de correctement se répartir le travail entre deux tâches principales : Nourrir le couvain et Butiner. Nous allons commencer par discuter de notre simulateur et de son architecture logicielle, puis du modèle physiologique de l'abeille adulte et du couvain, tiré de la biologie mais fortement simplifié. Nous verrons ensuite comment nous avons intégré le modèle de répartition des tâches décrit dans le chapitre précédent. Nous finirons par discuter de la calibration de ce système complexe, au plus proche de la biologie, tout en prenant en compte les différentes hypothèses et simplifications de notre modèle.
	
	\section{Description du Simulateur}
		\subsection{Architecture Logicielle}
			Pour réaliser ce simulateur, nous avions en tête quelques points clés. Cette thèse s'inscrit dans un projet plus grand, l'idée était donc de produire un simulateur propre, qui serai simple d'entretien et facile à améliorer et complexifier par la suite. De plus, notre bonne maitrise du langage Java, ainsi qu'un compromis entre confort d'écriture et performances nous a poussé à utiliser ce langage. Pour nous aider à mettre en place ces notions de propreté du code, nous avons utilisé des Interfaces Java, permettant de découpler des grande parties du programme, facilitant l'implémentation de modifications. Nous avons, le plus possible, pensé l'architecture en composants indépendants échangeant le moins d'informations possibles. Nous allons désormais décrire les principaux composants de cette architecture, la Figure \ref{ArchiLogicielle} résume le tout graphiquement.
			
			Le simulateur, en bon projet orienté objet, est pensé en couches d'abstraction successives. Au plus haut niveau, nous trouvons le lanceur, la classe \textit{BeekeeperLauncher}, le célèbre "\textit{main}", qui se charge des simulations. Il Présente deux modes :
	\begin{itemize}
		\item Interactions : mode pour lequel le simulateur est construit. Ce mode permet de lancer une simulation et prends en compte les interactions de l'utilisateur (via le réseau) pour altérer le comportement de la simulation.
		\item Barrage de Simulations : mode permettant de lancer un grand nombre de simulation à la suite, sans interactions possibles. Ce mode sert principalement pour calibrer certains paramètres.
	\end{itemize}				
			
			 Dans le mode "Interactions", le lanceur prépare le composant réseau qui servira à envoyer et recevoir les informations de l'application interactive, composant qui n'est pas instancié dans le mode "Barrage de Simulations". Le lanceur instancie ensuite le \textit{MainController}, le contrôleur principal, et lui partage le composant réseau si besoin. Le \textit{MainController} se charge de gérer une simulation. Désormais nous trouvons deux comportements différents pour les modes : en "Barrage de Simulations", les simulations s'enchainent à pleine vitesse, souvent en variant quelques paramètres. En mode "Interactions", lorsque la simulation est arrêtée, soit le programme s'arrête soit une autre est relancée avec les mêmes paramètres, selon ce qui a été décidé par l'utilisateur.
			 
			\begin{figure}
			\centering
			\includegraphics[width=\textwidth]{./Pictures/Figures/ArchiStart.png}
			\caption{Sequencement de l'initialisation d'une simulation.}{1- Le lanceur \textit{BeekeeperLauncher} instancie et initialise le \textit{MainController} qui se chargera d'une simulation. 1b- Dans le cas où le lanceur est dans le mode Interactions, il instancie un \textit{NetworkManager} et en donne la référence au MainController (Lors d'un changement de simulation, le \textit{MainController} est remplacé mais le \textit{NetworkManager} reste le même). 2- Le \textit{MainController} se charge désormais d'instancier un \textit{CombManager} avec les bons paramètres. 3- Le \textit{CombManager} commence par initialiser les \textit{Cadres}, il instancie en réalité des faces de cadres qu'il va associer par deux pour former les cadres de la simulation. 4- Une fois créés, les \textit{Cadres} sont alors peuplés par le \textit{CombManager} avec des \textit{Agents}. 5- Ensuite, des \textit{StimuliManager} sont instanciés par le \textit{CombManager} et associés à des faces de cadres.}
			\label{ArchiStart}
			\end{figure}
			
			\begin{figure}
			\centering
			\includegraphics[width=\textwidth]{./Pictures/Figures/ArchiLogicielle.png}
			\caption{Diagramme de classe esquissant l'architecture logicielle du simulateur.}
			\label{ArchiLogicielle}
			\end{figure}
			
			Le \textit{MainController} gère une simulation, une colonie d'abeilles. Il se charge d'instancier correctement les différents composants d'une simulation, et du bon déroulement de l'ensemble. Il compte les pas de temps, ce qui lui permet d'envoyer un signal aux agents, via un autre composant, leur ordonnant de vivre un pas de temps, ou lorsqu'il est temps de "logger". Via une interface Java, il offre un grand nombre de services haut niveau à différents composants, notamment au \textit{CombManager}, le manager des cadres, qu'il instancie avec les bons paramètres. Le \textit{CombManager} se charge d'instancier le bon nombre de faces de cadres, qui seront associées par deux en deux pour former les cadres, puis instancie les agents initiaux et les répartis sur ces cadres, via un autre composant, l'\textit{AgentFactory}, qui simplifie et centralise la création d'agents. La Figure \ref{ArchiStart} illustre les différentes interactions entre composants logiciels lors de l'initialisation d'une simulation.
			
			Chaque face de cadre possède une liste de cellules, des \textit{Cell}, qui elles même possèdent quelques attributs : leur numéro et leur position x et y sur le cadre ($numéro = y * largeur + x$), ainsi qu'une place "visite" pour un agent qui serait au dessus de la cellule, et une place "contenu", pour un agent à l'intérieur de la cellule ou de la nourriture, ou même rien, pour une cellule vide. Chaque face de cadre possède une liste contenant tous les agents que contiennent ces cellules. Cette liste agit comme un raccourcis, et permet de ne pas avoir à interroger toutes les cellules à chaque fois qu'on veut accéder aux agents. Le \textit{CombManager} possède aussi une liste d'agents, ceux qui n'appartiennent à aucun cadre, la liste de tous les agents à l'extérieur de la ruche, les butineuses.
			
			Le \textit{CombManager} est aussi responsable de la création, mise à jour, et bonne association des \textit{StimuliManager}, les managers de propagation des différents stimulus dans l'environnement. Chaque cadre a deux faces, et sont placés côte à côte. Ainsi, les faces se faisant face partagent le même \textit{StimuliManager}. 
			
			%POUR LES INTERACTIONS AVEC LE MODELE
			%Lorsque les cadres sont déplacés, de nouveaux \textit{StimuliManager} temporaires doivent être créés pendant le déplacement, puis lorsqu'ils sont reposés dans la ruche, le \textit{CombManager} se charge de refaire les bonnes associations, et combinaisons avec les temporaires.
			
			Un \textit{StimuliManager} est une grille 2D de la même taille qu'un cadre, dont chaque case possède plusieurs flottants, représentant les intensités des différents stimulus présents sur le cadre. Sa mise à jour utilise une méthode de "\textit{double buffering}" : la grille est lue et une deuxième est remplie avec les nouvelles valeurs. Une fois la lecture terminée, la deuxième grille prend la place de la première. La propagation se fait à chaque pas de temps pour chaque stimulus, afin de gagner du temps, l'évaporation se fait en même temps que le calcul de la propagation. Pour propager les stimulus, nous utilisons une fonction proche d'un flou en traitement d'image. Chaque pixel devient une moyenne pondérée de lui même et de tous ses voisins. Pour nous, chaque cellule voit sont intensité devenir la moyenne pondérée de sa propre intensité et de celles de ses voisines, en suivant cette équation :
			
			\begin{figure}
			\centering
			\includegraphics[width=0.4\textwidth]{./Pictures/Figures/flou.JPG}
			\caption{Filtre utilisé pour connaitre la nouvelle valeur de l'intensité du stimulus évalué. Avec $a$ la volatilité du stimulus évalué, et $N$ le nombre de voisin, ici $N=4$. Chaque pixel prend alors comme valeur la combinaison linéaire de sa valeur et de celles de ses voisins avec ce filtre pour coefficient.}
			\label{flou}
			\end{figure}
			
			\begin{equation}
			V0_{t+1} = p * ((1-a) * V0_t + \sum_{n=1}^{N} Vn_t * \frac{a}{N})
			\end{equation}
			
			Avec $V0_t$ la cellule évaluée à l'instant $t$, $Vn$ ses voisines et $N$ le nombre total de voisines. Nous utilisons aussi $a$ et $p$ deux paramètres de stimulus: la propagation dans l'espace $a$ (volatilité) et dans le temps $p$ (évaporation/amortissement). Ces paramètres nous permettent d'obtenir des comportements variés partageant les mêmes mécanismes. La figure \ref{flou} illustre cette équation sous la forme d'un filtre. Les valeurs d'évaporations sont alors utilisées sous la forme "par pas de temps". Pour mieux les contrôler, nous utilisons l'équation suivante pour les exprimer en demie-vie (durée après laquelle le stimulus aura perdu la moitié de son intensité), notion plus courante en biologie, puis les convertir en valeurs "par pas de temps" utilisables par l'algorithme :
			
			\begin{equation}
			k = \exp(\frac{-ln(2) * C}{\lambda})
			\end{equation}
			
			Avec $\lambda$ la demie vie en seconde, $C$ le coefficient appliqué pour convertir des secondes en pas de temps, et $k$ le coefficient à appliquer à chaque pas de temps pour obtenir une demie-vie de $\lambda$.
			
			\subsection{Architecture des Agents}
			Avec les mêmes objectifs en tête, lisibilité et facilité d'ajouts, nos agents ont été pensés en niveaux d'abstraction successifs. Au plus haut niveau nous trouvons la classe abstraite \textit{Agent}, qui regroupe l'âge, la position, l'énergie, la faim, une fonction abstraite \textit{live()}, ainsi que des fonctions de déplacement simples, comme le mouvement aléatoire. Nous définissons ensuite la classe \textit{EmitterAgent}, ou Agent Émetteur, qui hérite d'\textit{Agent} et ajoute les interactions avec un \textit{StimuliManager}, permettant d'émettre, ressentir des stimulus dans l'environnement. Enfin, héritant d'\textit{EmitterAgent}, nous trouvons la classe \textit{WorkingAgent}, ou Agent Travailleur, qui implémente enfin \textit{live()}, avec l'algorithme de sélection de tâches. La figure \ref{ArchiLogicielle} reprends aussi cette architecture. La fonction \textit{live()} se déroule en quelques étapes. D'abord on vérifie si l'agent est toujours en vie, ensuite nous mettons à jours ses perceptions. L'algorithme de sélection et exécution des tâches est alors appliqué, puis une fonction abstraite est appelée, fonction permettant de faire avancer le métabolisme de l'agent, et qui est implémentée différemment par nos différentes implémentations de \textit{WorkingAgent}. Nous avons pour l'instant 3 classes implémentant \textit{WorkingAgent}, les classes d'abeille adulte \textit{AdultBee}, de couvain \textit{BroodBee}, et de reine \textit{QueenBee}. Chacune de ces implémentations ajoute différentes tâches à sa liste de tâches (que nous allons décrire Section \ref{sectionModelColonie}), et implémente la fonction d'avancée du métabolisme.
			
			Ainsi, dans les plus hautes couches d'abstraction, les différents composants ont des références \textit{Agent}, ce qui améliore la modularité du programme, facilitant l'ajout de nouvelles implémentations de \textit{WorkingAgent} à l'avenir. 
			
			\subsection{Pas de temps et Multi-Thread}
			Afin d'accélérer nos simulations pour d'itérer plus confortablement dessus, nous avons mis en place un système de parallélisation, aussi appelé \textit{multi-thread}. Chaque duo de faces de cadres se faisant face, ainsi que le groupe des butineuses, vivent en concurrence, car ces différents ensembles n'interagissent pas entre eux. Pour ceci nous avons créé une classe \textit{WorkDispatcher}, qui s'occupe de gérer un groupe de \textit{thread}, de leur répartir le travail, d'en créer de nouveaux si nécessaire et de surveiller le moment où tous ont terminé leur travail. À chaque pas de temps, sur signal du \textit{MainController}, le \textit{CombManager} récupère et combine si nécessaire les différents groupes d'agents à faire vivre ensemble. Il envoi alors ces ensembles au \textit{WorkDispatcher} qui redirige la liste sur un \textit{thread} disponible. Chaque \textit{thread} va alors appeler la fonction \textit{live()} de chacun des agents. La Figure \ref{ArchiThread} illustre ces échanges.
			
			\begin{figure}
			\centering
			\includegraphics[width=\textwidth]{./Pictures/Figures/ArchiThread.png}
			\caption{Sequencement de la partie d'un pas de temps concernant les agents.}{1- Le \textit{MainController} envoie le signal au \textit{CombManager} de faire vivre les agents d'un pas de temps. 2- Celui-ci va alors récupérer les listes d'agents présents sur les cadres ainsi que celle des butineuses. 3- Il réarrange ensuite ces listes en rassemblant les agents ne pouvant pas vivre en concurrence, puis envoie ces listes aux \textit{WorkDispatcher}. 4- Ce-dernier va ensuite envoyer ces listes à des \textit{ExecutorThread} et en instancier de nouveaux s'il le faut. Ils vont alors, chacun en concurrence, parcourir leur liste d'agents et les faire vivre chacun leur tour. 5- Enfin, lorsque le \textit{WorkDispatcher} détecte que tous les threads ont terminé de faire vivre leurs agents, il le signal au \textit{CombManager} qui rend alors la main au \textit{MainController}.}
			\label{ArchiThread}
			\end{figure}
			
			Pour le cas particulier des butineuses rentrant dans la ruche, ou en sortant, deux listes synchronisées spéciales ont été ajoutées au niveau du \textit{CombManager}. Une liste contenant toutes les abeilles qui sont sorties de la ruche sur ce pas de temps, et une liste contenant celles qui sont rentrées. Les butineuses et les abeilles des cadres ne vivant pas sur les même \textit{threads}, une abeille rentrante ne peux pas être ajoutée directement au cadre. Ce n'est qu'après avoir fait vivre tout le monde, que le \textit{CombManager} se charge de faire les transferts, déplaçant les abeilles sortantes vers la liste des butineuses, et les abeilles entrante vers un cadre libre aléatoire.
			
			\subsection{Architecture des Tâches}
			Nos tâches sont décrites en subsomption hiérarchique dans le modèle, nous les avons donc implémenté de la sorte dans le simulateur. Au sommet de la hiérarchie nous trouvons la classe \textit{Tâche}, associant un seuil, un nom de tâche, différents paramètres et une activité racine. Une \textit{Tâche} est une classe abstraite : toute classe que nous voudrons instancier devra implémenter la fonction qui permet de calculer son score.
			
			La classe \textit{TaskNode}, ou Nœud de Tâche, est une interface très simple contenant deux fonctions : \textit{search} (recherche) et \textit{check} (vérifier). Elles nous permettent de mettre en place le fonctionnement de subsomption. La fonction \textit{check} représente la condition de chacun des blocs de notre subsomption, condition booléenne que chaque Nœud devra implémenter. Ensuite, la fonction \textit{search}, la principale, diffère selon les nœuds. La classe \textit{TaskNode} est implémentée par deux classes, \textit{Activité} et \textit{Action}, respectant notre modèle vu plus tôt. Vous trouverez Figure \ref{ArchiTask} un diagramme de classe de cette architecture. La fonction \textit{search} renvoi toujours une \textit{Action}, et permet d'interroger récursivement toutes la subsomption hiérarchique. La fonction \textit{search} de la classe Action renvoi l'instance d'\textit{Action} sur laquelle elle est appelée. En revanche, une \textit{Activité} est un peu plus complexe. Une \textit{Activité} possède une liste de \textit{TaskNode}, permettant la mise en place de la subsomption hiérarchique. Dans la fonction \textit{search}, l'\textit{Activité} va interroger un par un (dans l'ordre de priorité de la subsomption) la fonction \textit{check} de tous ses nœuds. Si l'un deux valide son \textit{check}, l'\textit{Activité} appelle alors le \textit{search} du nœud validé, mettant ainsi fin à la recherche.
			
			\begin{figure}
			\centering
			\includegraphics[width=0.8\textwidth]{./Pictures/Figures/ArchiTask.png}
			\caption{Diagramme de classe de l'architecture logicielle de Tâche.}
			\label{ArchiTask}
			\end{figure}
			
			Ainsi, pour qu'un agent puisse récupérer l'\textit{Action} à effectuer de sa \textit{Tâche} sélectionnée, il lui suffit d'appeler \textit{search} sur l'\textit{Activité} racine de la \textit{Tâche}. Récursivement, la recherche va descendre dans la subsomption dans les blocs aux conditions validées. Dès qu'une \textit{Action} est trouvée, sa fonction \textit{search} la renvoie et elle est remontée dans toutes les fonctions \textit{search} appelées précédemment, jusqu'à ressortir au niveau du tout premier \textit{search} que nous avons appelé sur l'\textit{Activité} racine de la \textit{Tâche}. L'\textit{Action} est prête à être exécutée par l'agent.
			
			
			\paragraph{}
			Pour conclure, lors d'un pas de temps, le contrôleur principal demande au manager des cadres de faire vivre tous les agents. Ce-dernier parcourt alors toutes ses faces de cadres et récupère tous leurs agents, afin de les envoyer aux gestionnaire de \textit{thread} pour une exécution parallèle. Une fois tous les agents mis à jour, les agents entrant et sortant de la ruche sont transférés. Si le contrôleur principal a demandé à "log" le tour, alors une nouvelle mécanique s'enclenche. Le manageur des cadres récupèrent à nouveau la liste de tous les agents, et leur demande de décrire en une ligne leur état : numéro d'identifiant, tâche, énergie, HJ et EO. À cette ligne est ajoutée au début le numéro du pas de temps transmis par le contrôleur principal. Toutes ces lignes sont alors envoyées au \textit{Logger}, qui les transfère sur un autre \textit{thread} afin d'être écrites dans un fichier, permettant une trace de la simulation, pour utilisations ultérieures en analyse de résultat.

	\section{Modélisation de la Colonie d'Abeilles}
	\label{sectionModelColonie}
		\subsection{Modélisation des Agents "Abeille Adulte"}
		
		Dans notre colonie virtuelle et en bref, les adultes (qui sont désormais des agents) tendent toutes à aller butiner rapidement, grâce à l'Hormone Juvénile (HJ) qu'elles sécrètent, mais sont retenues "nourrices" par l'Ethyle Oléate(EO) émise par le couvain et les butineuses, qui "détruit" une part de leur HJ. Les détails de la biologie de l'abeille, des phéromones en jeu et leurs effets sur l'auto-organisation sont décrits dans la Section \ref(sectionBio), au début de ce manuscrit. Cette rétroaction permet de réguler le nombre de nourrices et de butineuses au sein de la colonie : lorsqu'il y a beaucoup de couvain, très peu d'adultes vont partir butiner, car le couvain va injecter de grande quantité d'EO dans les agents de la colonie, et certaines butineuses peuvent même redevenir des nourrices. Lorsque les butineuses meurent de vieillesse, elles freinent moins le développement des nourrices, et certaines pourront partir butiner. Ces différentes interactions ont été synthétisées Figure \ref{HJEODynamics}. Dans les colonies réelles, les butineuses échangent très régulièrement des phéromones avec les receveuses, qui sont chargées de délester les butineuses de leur cargaison pour aller les stocker dans un endroit adapté dans la ruche. Nous posons une hypothèse ici, qui est que les receveuses sont un vecteur majeur de l'effet rajeunissant des butineuses sur les nourrices. Or, comme nous ne simulons pas de tâches de receveuses dans cette itération du modèle, nous nous attendons à ne presque pas observer ce mécanisme.
		
		L'Hormone Juvénile (HJ) représente directement la physiologie de nos agents abeilles adultes, ce que nous appelons l'âge physiologique en référence au polyéthisme d'âge que nous observons dans les colonies réelles. Un agent avec très peu d'HJ ($HJ < 0.5$), sera capable de nourrir le couvain mais incapable de butiner. À l'inverse, un agent avec un fort taux d'HJ ($HJ > 0.5$), sera capable de butiner mais incapable de nourrir le couvain. On parle donc de nourrices lorsque nous considérons les agents physiologiquement jeune, et de butineuses pour les agents physiologiquement âgées. Nous avons ajouté un paramètre à nos agents, leur développement ovarien, toujours nul sauf la reine pour qui il vaut 1. Cette variable n'est pas utilisée dans cette itération de l'implémentation, mais permettra de simuler les ouvrières pondeuses que nous retrouvons dans la réalité, lorsque les phéromones de la reine ne parviennent plus à certaines ouvrières en périphérie de la colonie et que ces dernières commencent à pondre.
		
		Dans nos lectures, nous avons pu apprendre que les abeilles d'hiver pouvaient vivre jusqu'à une année entière, mais que les butineuses meurent en une trentaine de jours, avec en moyenne les dix derniers jours passés à butiner. Les biologistes pensent que le vol est une activité très épuisante, et qu'il est possible qu'il réduise fortement l'espérance de vie des butineuses. Nous avons donc implémenté ce mécanisme pour les morts de vieillesses de nos agents. Ils meurent en une année, mais subissent une pénalité lorsqu'ils butinent. Ainsi, un agent qui butine voit son âge effectif (celui qui est utilisé pour déterminer la mort de vieillesse) augmenter trente fois plus vite qu'un agent à l'intérieur de la colonie.
		
		Nos agents sont placés sur le cadre, savent que la sortie s'effectue par le bas (et savent aller vers le bas). Le travail de butinage est laissé très simple, le fourragement ne faisant pas partie de nos priorités ici. En effet, ce mécanisme passionnant fait déjà l'objet de grandes quantités de recherches, et nous nous concentrons ici sur l'intérieur de la ruche. À l'avenir, une simulation plus poussée des mécanismes de fourragement, sélection des sources de nectar, recrutement etc. pourront être ajoutés au modèle. Pour l'instant, les butineuses sortent de la ruche, attendent simplement pendant un nombre donné de pas de temps puis rentrent à nouveau dans la ruche, sur un cadre aléatoire possédant une case disponible au niveau de sa ligne la plus basse. La durée de ce butinage est pour l'instant la même systématiquement, pour tous les agents, et correspond à une valeur moyenne des temps de butinages observés pour des butineuses réelles.
		
			
			\begin{figure}
			\centering
			\includegraphics[width=\textwidth]{Pictures/Figures/ImplemDynamics.png}
			\caption[Notre modélisation de la physiologie de l'abeille adulte.]{Modélisation simplifiée des effets physiologiques responsables de l'auto-organisation.}
			\label{HJEODynamics}
			\end{figure}
		
		
		\subsection{Modélisation du Couvain}
		
			Nous avons modélisé les trois étapes majeures de la vie du couvain : œuf, larve et nymphe. Seule la larve requiert de la nourriture, les deux autres étapes n'ont pas besoin de nourrice pour se dérouler correctement. La nymphe n'émet aucune phéromone, la cellule étant fermée et l'EO que nous avons modélisée étant transmise par contact. Un agent larve émet de l'EO en permanence, nous avons aussi fait le choix de faire émettre ces phéromones par les agents œufs. Plusieurs aspects ont motivé ce choix, que nous n'avons pas pu confirmer ou infirmer en biologie : l'œuf est pondu par la reine qui émet des phéromones très puissantes, elle en transmet donc surement à l'œuf pendant la ponte. De plus, n'ayant pas simulé les receveuses, le mécanisme de rajeunissement des nourrices par les butineuses est minoré, l'œuf permet donc de compenser légèrement ce biais. L'œuf ayant une durée de vie très courte, seulement 3 jours sur les 21 totaux, il est tout à fait possible que cette émission n'ait quasiment aucun effet.
			
			Les phéromones émises par les agents du couvain le long de leur vie vont altérer la physiologie des agents adultes. Elles sont échangées lorsqu'un agent adulte passe sur la case d'un agent couvain, et en plus grande quantité lorsqu'un agent effectuant la tâche de nourrisse vient déposer de la nourriture à l'agent larve.
		
	\subsection{Tâches et Auto-Organisation}
		Le but de notre simulation est de retrouver un équilibre dans le partage des tâches entre ces deux tâches clés : Butiner et Nourrir le couvain. Ces deux tâches ne présentent pas de stimulus déclencheur direct comme nous avons pu en discuter dans le chapitre précédent. Nous avons donc recourt à une motivation source pour ces deux tâches, que nous plaçons arbitrairement à $0.5$. Cette motivation source est abaissée à 0 lorsque l'abeille n'est pas physiologiquement apte a réaliser la tâche, ou, pour le butinage, si l'agent n'a pas suffisamment d'énergie pour survivre le vol aller-retour. Ensuite, nous utilisons la HJ de chaque agent pour ajuster le seuil de chacune de ces deux tâches. Moins une abeille a d'HJ, plus elle aura de chance de sélectionner la tâche de nourrice, et plus une abeille aura d'HJ, plus elle aura de chance de sélectionner la tâche de butineuse (vous retrouverez la description des modèles à seuils Section \ref{subsectionRTM} Le débattement des seuils a été ajusté pour empêcher le score de la tâche de dépasser $0.8$ : l'intervalle $[0.8 ; 1]$ est réservé aux tâches prioritaires, que nous allons maintenant décrire. En effet, si nos agents doivent se répartir deux tâches principales, ce ne sont pas les seules, nous avons ajouté des tâches d'entretiens : se reposer, donner à manger, demander à manger. Ces tâches ne sont pas motivées, elles possèdent des stimulus déclencheur, la faim et l'énergie. La tâche de repos est prioritaire, son score est donc autorisé à dépasser $0.8$. En effet, si l'énergie d'un agent devient négative, il meurt\footnote{Dans cette version du modèle nous avons fait le choix de ne représenter la nourriture qu'au plus simple. Ainsi, la mort par sous alimentation ne fait pas partie de cette itération. L'importance des butineuses en est donc fortement réduite : même si 100\% de la colonie s'occupe du couvain, il y aura toujours suffisamment de nourriture. Ajouter la nourriture, détailler ses mécanismes de distribution et introduire son mécanisme de collecte est une des perspectives privilégiées pour la suite.}. Le couvain possède aussi trois tâches très simple, une pour chacune de ses étapes de développement. Ces différentes tâches altèrent seulement leurs émissions de phéromones (en effet, le seul rôle du couvain est de se nourrir). La reine possède une tâche lui permettant de pondre. Vous trouverez Table \ref{tableTasks} un récapitulatif de toutes les tâches implémentées.
		
		\begin{table}
        \centering
        \caption{Les différentes tâches que nos agents peuvent exécuter.}
        \begin{tabular}{|l|l|}
            \hline
            Nom de tâche & Calcul du score\\
            \hline
            \hline
            \multicolumn{2}{|l|}{Tâches d'entretien}\\
            \hline
            Se reposer & 1-Energie [0;1]\\
            Demander à manger & Faim [0;0.8] \\
            Donner à manger & Stimulus de demande détecté [0;0.8] \\
            Déplacement aléatoire & 0.2 (tâche par défaut) \\
            \hline
            \hline
            \multicolumn{2}{|l|}{Tâches Principales (et motivées)}\\
            \hline
            Butiner & 0 si $HJ<0.5$, sinon Sigmoïde seuil : 1-JH déplacé dans [0.3;1] \\
            Nourrir le couvain & 0 si $HJ>0.5$, sinon Sigmoïde seuil : JH déplacé dans [0.3;1] \\
            \hline
            \hline
            \multicolumn{2}{|l|}{Tâches du couvain et de la reine}\\
            \hline
            Tâche d'oeuf & 1 si âge d'oeuf, 0 sinon (le couvain n'a pas besoin de repos)\\
            Tâche de larve & 1 si âge de larve, 0 sinon\\
            Tâche de nymphe & 1 si âge de nymphe, 0 sinon \\
            Pondre & 0.8 si développement ovarien, 0 sinon\\
            \hline
            
        \end{tabular}
        \label{tableTasks}
    \end{table}
    
	\section{Calibration des Phéromones}
	
	La répartition des tâches au sein de la colonie, en particulier le nourrissage et le butinage, dépendent majoritairement de mécanisme d'hormones et de phéromones. Comme nous l'avons vu plus tôt, nous nous intéressons ici au bras de fer entre l'Hormone Juvénile (HJ) et l'Ethyle Oléate (EO), comme décrit Figure \ref{HJEODynamics}.
	
	Paramétrer cette dynamique a été un processus complexe : notre grande simplification du modèle, et surtout des différentes phéromones nous détache, pour cette partie, de la réalité biologique. Nous avons donc émis des hypothèses, fixé des paramètres arbitrairement, dans le but de retrouver d'autres "macro-paramètres" émergents. Les deux points clé de cette paramétrisation sont 1) La quantité relative d'EO émise par rapport à l'HJ, et 2) La force des effets de l'HJ et de l'EO. De plus, la paramétrisation s'articule autour de deux points d'équilibre : l'équilibre en EO ($EO_{Eq}$), qui représente le moment où un agent a suffisamment d'EO pour parfaitement compenser son vieillissement, et donc son émission d'HJ. L'autre point d'équilibre, cette fois a l'HJ ($HJ_{Eq}$), représente le moment où un agent sécrète la bonne quantité d'HJ pour parfaitement compenser l'évaporation d'EO, et donc maintenir le niveau de cette-dernière.
	
	\subsection{Hypothèses et décisions arbitraires}
	Étant loin de la biologie, les quantités absolues des différentes substances ne sont en rien liées à la réalité, nous avons donc pu choisir arbitrairement les quantités et points d'équilibres. Nous avons donc décidé de fixer la quantité d'HJ dans $[0;1]$, et $HJ_{Eq} = 0.8$. De son côté, la quantité d'EO est simplement comprise dans $[0;\infty[$, et avec $EO_{Eq} = 1$. 
	
	Ainsi, un agent abeille adulte avec un taux d'HJ supérieur à $HJ_{Eq}$ va émettre plus d'EO qu'il ne s'en évapore sur lui, et va rajeunir. Un agent avec un taux d'EO inférieur à $EO_{Eq}$ va éliminer moins d'HJ qu'il n'en émet, et va donc vieillir.
	
	\paragraph{}
	Nous faisons ici l'hypothèse que la réduction d'HJ par l'EO se fait seulement avec une fonction prenant en compte la quantité d'EO. De même pour l'émission d'EO en fonction de la quantité d'HJ qui ne se fait que via une fonction dépendante de la quantité d'HJ de l'agent concerné. Nous posons aussi que ces fonctions ont la forme $x^n$, avec $n$ un paramètre fixé expérimentalement (que nous décrirons plus tard) et $x$ la différence entre le taux courant et la valeur d'équilibre donnée plus tôt.
	
	Les deux effets énoncés précédemment sont imbriqués dans une boucle de rétroaction. Les quantités absolues de ces éléments ne sont donc pas pertinentes, en revanche, les écarts entre ces deux produits provoquent la dynamique que nous recherchons. Nous avons ainsi décidé, pour simplifier le paramétrage, d'en fixer un et de chercher le deuxième. Nous avons donc fixé l'émission d'EO en fonction de l'HJ à une fonction linéaire :
	
	\begin{equation}
		EO_{em} = (HJ - HJ_{Eq}) * EO_{Evap}
	\label{eoEM}
	\end{equation}

Avec $EO_{Evap}$ la quantité d'EO qui s'évapore lorsque l'on considère une quantité d'EO égale à $EO_{Eq}$. Nous retrouvons donc la fonction sous la forme $s=x^n$ décrite plus tôt, avec $n = 1$ et $x$ l'écart d'HJ à l'équilibre facteur de $EO_{Evap}$.
	
	
	\subsection{Intensités des effets}	
	Après avoir fixé ces paramètres, nous devons nous atteler à trouver la bonne combinaison d'intensité des effets des substances, ainsi que la quantité à laquelle on veut les émettre. Pour l'HJ, il suffit de prendre le point de transition, nous avons choisi 0.5, et de le diviser par la quantité de pas de temps minimum qu'il faut pour l'atteindre. Nous pouvons décider de la majorer légèrement afin de prendre en compte l'effet de l'EO, ralentissant très légèrement le vieillissement en faible quantité. Ce ralentissement est cependant très faible pour un agent isolé, ainsi nous n'avons pas gardé l'option de la majoration.
	
	Nous avons ainsi la quantité d'HJ émise par chaque agent à chaque pas de temps, que nous appellerons désormais $HJ_{Incr}$. L'EO présente sur chaque agent viendra éliminer une partie de son HJ, combattant ainsi indirectement cet $HJ_{Incr}$, dont nous pouvons désormais nous servir comme référence. Nous voulons qu'à $EO_{Eq}$, la réduction d'HJ $HJ_{red}$ soit égale à $HJ_{Incr}$, pour compenser parfaitement le vieillissement de l'agent. Nous pouvons donc écrire :
	
	\begin{equation}
		 HJ_{red} = (EO - EO_{Eq})^n * HJ_{Incr}
	\label{hjRED}
	\end{equation}
	
	Avec $n$ un coefficient dont nous allons nous servir pour modeler l'intensité de l'effet de réduction d'HJ. Avec $n=1$ (Figure \ref{eoLinear}), notre fonction est linéaire, nous nous servirons de cette fonction comme base de comparaison. Lorsque $n>1$, on obtient une fonction quadratique (Figure \ref{eoSquared}). L'effet rajeunissant de l'EO est diminué avant $EO_{Eq}$ et amplifié après. Nous obtenons donc un vieillissement ainsi qu'un rajeunissement plus rapide. L'effet de l'EO est amplifié lorsque $n$ augmente. Enfin, avec $n < 1$, on obtient une fonction racine (Figure \ref{eoSqrt}). De la même manière, avec une racine, l'intensité des effets de l'EO est réduite.
	
	Pour illustrer, nous pouvons aussi imaginer que l'abeille vieillit naturellement rapidement. Mais, cet état d'équilibre est altéré par l'EO, nous pouvons donc visualiser ceci comme l'abeille étant attachée par un ressort à ce point d'équilibre. La rigidité de ce ressort peut alors être interprétée comme la puissance de l'EO, proportionnelle à n. Plus n est grand, plus l'abeille sera tirée vers ce point d'équilibre, qu'elle soit avant ou après.
	
	Nous n'avons pas trouvé de moyen de fixer mathématiquement n, ni dans la littérature, ni même après mûres réflexions : il a donc été trouvé expérimentalement, nous y viendrons dans la partie suivante, concernant la calibration.
	
	\begin{figure}
	\centering
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/Figures/EOEffectsLINEAR.png}
	\caption{Réduction d'HJ \textbf{linéaire} (exposant $= 1$) par l'abeille en fonction de la quantité d'EO qu'elle possède. Lorsque $EO = EO_{Eq}$, la réduction compense parfaitement le vieillissement naturel de l'agent : $HJ_{Red} = HJ_{Incr}$.}
	\label{eoLinear}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/Figures/EOEffectsSquared.png}
	\caption{Lorsque la fonction de réduction est \textbf{quadratique} (exposant $> 1$) plutôt que linéaire (Fig \ref{eoLinear}), on observe à gauche que l'EO a moins de puissance avant $EO_{Eq}$, et beaucoup plus après. A droite, on voit donc que le vieillissement ainsi que le rajeunissement (quand $EO > EO_{Eq}$) sont plus intenses.}
	\label{eoSquared}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.9\textwidth]{Pictures/Figures/EOEffectsSQRT.png}
	\caption{Lorsque la fonction de réduction est \textbf{une racine} (exposant $< 1$) plutôt que linéaire (Fig \ref{eoLinear}), on observe à gauche que l'EO a plus de puissance avant $EO_{Eq}$, et beaucoup moins après. A droite, on voit donc que le vieillissement ($EO < EO_{Eq}$) ainsi que le rajeunissement ($EO > EO_{Eq}$) sont plus doux.}
	\label{eoSqrt}	
	\end{subfigure}
	
	\caption[Différents degrés de fonctions pour ajuster l'intensité des effets de l'Ethyle Oléate sur les abeilles adultes.]{Différents degrés de fonctions pour ajuster l'intensité des effets de l'Ethyle Oléate sur les abeilles adultes. Pour toutes les figures, à gauche les flèches indiquent la force de réduction de l'EO, à droite elles indiquent la vitesse de vieillissement (en rouge lorsque l'agent vieilli, en bleu lorsqu'il rajeuni).}	
	\label{eoAll}
	\end{figure}
	
	
	
	\subsection{Quantités Émises par les Agents Larves}
	\label{subsesctionPHLarves}
	Un autre point clé de ce modèle est la capacité des agents larves à influer directement la physionomie des adultes, en contraignant certain à rester physiologiquement jeunes. Il faut donc  que ces larves en émettent la bonne quantité : trop peu et il n'y aura pas assez de nourrices pour s'occuper du couvain, trop et il n'y aura plus assez de butineuses à la récolte de nourriture.
	
	La quantité d'EO émise par chaque larve est donc importante, car elle est censée permettre à l'abeille de rester jeune, et même de rajeunir. Nous avons donc commencé par placer cette émission à $EO_{Evap}$ (Voir eq. \ref{eoEM}). De plus, les contacts étant assez bref, l'émission d'EO des larves doit permettre à une nourrice sollicitée de rester jeune malgré quelques temps de trajets. Ce dernier point porte une incertitude liée a l'émergence de ce comportement : la répartition des larves sur le cadre, les temps de trajets des nourrices entre les larves qui accepterons de la nourriture, l'aléatoire dans le trajet même que va choisir la nourrice etc. Nous avons donc décidé de placer l'émission des larves à $k * EO_{Evap}$, avec k un coefficient que nous allons trouver expérimentalement, qui sera forcément supérieur à 1. En effet, nous savons qu'en dessous les larves n'auront pas le pouvoir d'empêcher les nourrices de vieillir et de partir butiner par la suite. La question est donc de savoir, à quel point il doit être supérieur à 1.
	
	\subsection{Objectifs de calibration}
	\label{subsectionObjectifCalibration}
	Nous saurons que le coefficient $k$ de l'émission d'EO des larves est juste lorsque, peu importe la quantité de larves, la proportion de nourrice par rapport aux butineuses sera globalement constante. Avec une émission trop importante, augmenter le nombre de larve va drastiquement augmenter le ratio de nourrices. Par exemple lors d'un essai, nous obtenions un ratio de 1 butineuse pour 1 nourrice avec 500 larves, mais presque 100\% de nourrice pour 1000 larves. A l'inverse, lorsque trop peu de nourrices sont captées par le couvain, ce coefficient doit être augmenté.
	
	Ensuite, il arrive qu'il faille diminuer la quantité d'EO émise par les larves, alors qu'elle est déjà trop faible pour un petit nombre de larves (ou vice versa). C'est ici le signal que l'intensité des effets de l'EO sur les adultes est à ajuster, en variant l'exposant de l'équation donnant $HJ_{Red}$ (Eq \ref{hjRED}). Ainsi, lorsque 500 larves maintiennent un ratio nourrices/butineuses correct mais faible, mais que 1000 retiennent trop de nourrice, c'est que l'EO a trop d'effet, il faut alors abaisser l'exposant de $HJ_{Red}$. 
	
	Nous avons gardé un exposant entier lorsqu'il est supérieur à 1, et de la forme $1/x$ (avec $x$ entier) pour un exposant inférieur à 1.
	
	
	Ce mécanisme par échange de phéromones est à la base de ce que nous cherchons à démontrer ici, et est profondément émergent, car dépendant des interactions entre tous nos agents, ce qui explique notre recours ici à un paramétrage expérimental. La méthodologie et les résultats de la calibration seront présentés et discutés dans le chapitre suivant.
			
	\section*{Conclusion}
		Dans ce chapitre nous avons discuté de l'architecture logicielle du simulateur qui fait tourner notre première itération du modèle. Nous agents à l'intérieur de la colonie doivent se répartir deux tâches automatiquement, "Nourrir les larves" et "Butiner". Plusieurs couches d'abstraction nous offrent une grande modularité dans le développement, et l'utilisation de plusieurs \textit{thread} d'exécution permet d'accélérer la simulation, nous permettant d'itérer plus confortablement sur le modèle. Nous avons ensuite décrit l'implémentation concrète du modèle de sélection et d'interruption de tâche, à partir de ce que nous avons pu construire au chapitre précédent : les seuils pour la physiologie de l'agent, modéliser les tâches en Activité ainsi qu'en Action, parfois démotivante etc. Nous avons aussi décrit l'implémentation du modèle physiologique simplifié de l'abeille adultes, ses glandes, hormones, phéromones et leurs influences mutuelles et sur le comportement de nos agents. Après calibration de certains paramètres émergents difficile à pré-calculer ou à estimer, nos agents devraient être capable de se répartir le travail sans contrôle central, et de manière dynamique, en s'adaptant aux changements d'environnement et de populations. Dans le chapitre suivant nous allons pouvoir nous intéresser à cette auto-organisation, comment la mesurer, est-elle satisfaisante ? Nous parlerons aussi de calibration expérimentale, amenée par le caractère émergent de beaucoup de paramètres à retrouver nous venant d'observation de colonies réelles.
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	