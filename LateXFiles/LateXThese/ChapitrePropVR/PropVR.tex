\chapter{Propositions : Visualisation et Interactions avec la Colonie d'Abeilles Virtuelle}
\label{ChapitrePropVR}

		Nous souhaitons permettre à un utilisateur d'interagir avec notre simulation multi-agents de la colonie d'abeilles. De manière générale, les apiculteurs manipulent leurs ruches en ne manipulant que les cadres. Ils effectuent parfois certaines actions directement sur les reines, comme la placer dans une petite cage pour limiter ses mouvements, ou tout simplement la retirer et/ou en insérer une nouvelle. Nous ne nous intéressons pas pour l'instant à ces cas particuliers, et avons décidé de permettre à l'utilisateur de seulement manipuler les cadres de la ruche. En effet, déplacer des cadres ou en remplacer par d'autres altère fortement l'environnement de la colonie. Les individus la constituant doivent alors faire preuve d'auto-organisation afin de s'adapter à ces nouvelles conditions. En plus de provoquer cette réaction d'auto-organisation, nous souhaitons l'observer, et visualiser en détail les mécanismes qui la provoquent.
		
		Nous nous sommes ainsi intéressés en particulier au cas de la division. La division est un geste apicole séparant une colonie, dont la population est trop importante, en deux colonies. Une colonie trop populeuse laissée en autonomie va "essaimer" : les ouvrières vont élever une nouvelle reine, puis une bonne partie va la suivre lors de son envol pour former une nouvelle colonie, ailleurs. La division permet à l'apiculteur de prévenir un éventuel essaimage et de garder le contrôle sur les deux nouvelles colonies, au lieu d'en perdre une dans la nature. Pour réaliser une division, les apiculteurs collectent différents cadres et les abeilles présentes dessus, et essayent de diviser au mieux la colonie en deux. Une nouvelle ruche est alors remplie de quelques cadres, en essayant d'y intégrer des abeilles de tous âges, du couvain de tout âge ainsi que différentes ressources. Les proportions doivent être à peu près les mêmes pour la colonie source et la nouvelle colonie, afin de ne pas en condamner une. Les espaces vides laissés par les cadres déplacés de chaque ruche sont comblés par de nouveaux cadres vides.
		
		Dans les quelques jours suivants la division, les ouvrières vont adapter leur physiologie pour compenser un potentiel déséquilibre dans la répartition des tâches. Les nourrices commencent à élever une nouvelle reine, à partir d'une très jeune larve. Tant que la nouvelle reine ne commencera pas à pondre, la colonie est en danger. Le couvain apporté par la division grandit et émerge peu à peu. Une vingtaine de jours après la division, la reine commence à pondre alors qu'il ne reste quasiment plus de couvain datant d'avant la division. Une fois la ponte démarée, la colonie reprend une vie normale, sans que la division ne laisse de trace sur son organisation.
		
		

	\section{Commandes de l'Utilisateur}
	
	Pour permettre à un utilisateur d'effectuer une division, voici la liste des actions qu'il doit pouvoir effectuer (construite en collaboration avec un apiculteur du \textit{GDSA29}), et dont l'implémentation est décrite dans la section suivante :
		\begin{itemize}
			\item attraper un cadre;
			\item frapper le cadre manipulé : cette action permet d'en faire tomber les abeilles, afin de pouvoir observer le contenu du cadre ( cette action est presque systématique pour l'apiculteur);
			\item lâcher le cadre manipulé : soit dans la ruche sur un emplacement de cadre vide, soit à l'extérieur, permettant ainsi de laisser un emplacement vide (un cadre peut aussi être lâché dans une deuxième ruche, permettant de simuler la division);
			\item valider la division : cette action importante isole l'une des deux ruches (au choix de l'utilisateur). Les cadres et abeilles alors présents dans l'autre ruche sont retirés de la simulation;
			\item accélérer le temps : l'utilisateur demande au simulateur de ne plus respecter le temps réel pendant une période donnée ( Le simulateur alors débridé calcule plus rapidement pour cette période, puis repasse en mode temps réel);
			\item redémarrer la simulation;
			\item arrêter la simulation, fermer l'application.
		\end{itemize}	
		
		D'autre part, l'utilisateur doit pouvoir visualiser certaines informations au sujet de la colonie en général ou de chaque individu. Nous remontons pour l'instant les informations suivantes à l'utilisateur, en vue d'une visualisation adaptée :
		\begin{itemize}
			\item la position dans la ruche de chaque agent (incluant les agents hors de la ruche, en butinage);
			\item ee contenu des différents cadres;
			\item l'état de chaque agent : sa tâche en cours, son âge réel, son âge physiologique ainsi que la quantité de phéromones qu'il a échangées.
		\end{itemize}		

	\section{Architecture Logicielle}
	
	Nous décrivons dans cette section l'architecture logicielle permettant la mise en place des interactions et visualisation que nous venons de décrire.
	
	\subsection{Communications}

	\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{Pictures/Figures/Distrib.png}
	\caption{Architecture du simulateur et de l'application interactive.}
	\label{archi}
	\end{figure}
	
	
	Nous proposons de séparer la simulation et sa visualisation, suivant les conseils de Louloudi et. al. \cite{louloudi_new_2012}, en utilisant un serveur Java pour exécuter la simulation, et un client \textit{Unity3D} pour la visualisation et les interactions. Comme nous pouvons le voir sur la Figure \ref{archi}, le simulateur et l'application interactive sont totalement séparés et communiquent via le réseau, en utilisant des requêtes UDP ou TCP selon les besoins. Nous n'utilisons toutefois pas de composant "relai" universel permettant le lien entre les deux parties, comme proposé par l'équipe de Louloudi. Ce rôle est tenu à la fois par le protocole de communication UDP/TCP que nous avons élaboré, et par un composant dédié aux communications dans chaque partie du système. Le simulateur et l'application interactive possèdent chacun un composant de communication réseau indépendant, permettant d'envoyer et recevoir des messages réseau.
	
	En plus des bénéfices cités par Louloudi et al. \cite{louloudi_new_2012}, cette séparation permet de limiter l'impact des contraintes d'un support sur l'autre : la simulation est conçue libre des contraintes de l'application de visualisation et d'interaction, et \textit{vice versa}. 	
	
	\begin{table}
		\begin{tabularx}{\textwidth}{|l|l|l|p{2cm}|X|}
		\hline
		\textbf{Fréq} & \textbf{Mot Clé} & \textbf{Param} & \textbf{Donnée(s)} & \textbf{Effets}\\
		\hline
		\multicolumn{5}{|l|}{\textbf{TCP}} \\
		\hline
		- & STARTUDP & - & \{combId\} & La liste des identifiants des cadres de la simulation, en réponse aux STARTUDP et RESTART du client.\\
		\hline
		- & DEATHS & nb & \{agentId\} & La liste des identifiants des agents morts depuis la dernière requête "DEATHS", liste de longueur "nb".\\
		\hline
		\multicolumn{5}{|l|}{\textbf{UDP}} \\
		\hline
		1/2 & AGENTS & combId & \{agentId,\newline X, Y\} & La liste des agents présents sur la face de cadre numérotée "combId". Ensuite, pour chaque agent, son numéro d'identification "agentId" ainsi que sa position "(X,Y)" sur le cadre.\\
		\hline
		1/4 & FORAGERS & - & \{agentId\} & La liste des identifiants "agentId" de tous les agents à l'extérieur de la ruche.\\
		\hline
		1/20 & CONTENT & combId & \{Nb,\newline contentId,\newline fill\} & Le contenu de la face de cadre numérotée "combId". Les données contiennent ensuite pour chaque cellule du cadre, son numéro "Nb" (lié à sa position), un identifiant "contentId" indiquant le type de contenu et son taux de remplissage "fill".\\
		\hline
		1/4 & STATES & timeStep & \{agentId,\newline age,\newline HJ,\newline phEx\} & Les états courant de tous les agents adultes. À la suite et pour chaque agent la liste contient son identifiant "agentId", son âge, son taux d'HJ ainsi que la quantité de phéromones "phEx" que l'agent a échangé.\\		
		\hline
		\end{tabularx}
	\caption{Tableau récapitulant les messages du serveur vers le client, leurs types et leurs sens.}
	\label{tabServClient}
	\end{table}
	
	Les communications du serveur vers le client se font majoritairement via UDP. Ce protocole simple permet l'envoi de grandes quantités de données, mais ne garantit pas la bonne réception de ces dernières. Ainsi, nous nous en servons pour transmettre sous la forme d'un flux les différentes données de la simulation à l'application interactive. En cas de mauvaise réception, la prochaine réception du flux écrasera les erreurs avec les données correctes. Ainsi, les positions des agents, leur âge etc. passent par un flux UDP, formaté sous la forme :	
	\begin{center}
		[Mot Clé] [Paramètre] \{Données\}
	\end{center}
	Cette forme unique nous permet de faciliter le décodage de ces informations à la réception. Le mot clé permet d'orienter rapidement l'application client vers la bonne manière de traiter la suite des données. La Table \ref{tabServClient} présente les commandes que nous utilisons, nous pouvons par exemple voir que la première commande décrit par ce tableau a pour mot clé "STARTUDP". Ensuite, le paramètre permet de transmettre une information importante, qui n'a pas sa place dans le gros des données, comme par exemple le numéro d'identifiant de la face de cadre dans la commande indiquant la position de chaque agent sur cette face. Lorsqu'il n'est pas utilisé, ce paramètre est placé à -1, afin d'éviter que la première donnée soit comptée comme le paramètre. Ensuite les données consistent en une suite de caractères, séparés par des espaces. 
	Le serveur utilise le protocole TCP pour communiquer des accusés de réception au client. Dans deux cas la réponse TCP du serveur est un peu plus complexe. Le premier cas, lors du démarrage ou du redémarrage d'une simulation, le serveur envoie via TCP les identifiants ordonnés des cadres présents, permettant au client d'en connaitre le nombre et leurs positions les uns par rapport aux autres. Le second concerne la mort des agents. C'est en effet une information importante, nous ne voulons pas que le client la rate, car elle ne sera pas renvoyée. Ainsi, les identifiants des agents morts sont communiqués au client via TCP, sur une demande du client. 
	Le Tableau \ref{tabServClient} récapitule les principales communications du serveur vers le client, en omettant les accusés de réceptions simples.
	
	Le tableau nous informe aussi de la fréquence des envois UDP, sur sa colonne "Fréq". En effet, afin de ne pas surcharger le client et le réseau, ces informations ne sont pas envoyées systématiquement. Le serveur fonctionne de manière autonome par rapport à la simulation, et possède ses propres pas de temps définis. Ce découplage permet de ne pas envoyer de données à chaque pas de temps du simulateur, ce qui pourrait poser problème lorsque ce dernier est débridé. Le volume de données transitant par le réseau est alors relativement constant, peu importe si la simulation est en avance rapide ou non. En effet, lors d'une avance rapide, le serveur cesse d'envoyer les positions des agents, les agents en butinage ainsi que le contenu des cadres. Ne sont envoyées que les activités des agents, la commande "\textit{STATES}" (ici et dans la suite de ce document, les commandes/messages sont nommés par leur mot clé). En effet, en avance rapide, ces informations concernant chaque abeille changent extrêmement rapidement et ne sont alors pas pertinentes pour l'utilisateur et surchargeraient l'outil de visualisation. Ces envois reprennent normalement à la fin de l'avance rapide.
	Les fréquences sont données dans le tableau en pas de temps réseau. Par exemple, la commande "\textit{CONTENT}" n'est envoyée qu'un pas de temps réseau sur 20, lorsque le simulateur est en mode temps réel. 
	
 	Le serveur est aussi bridé afin de ne pas pouvoir être plus rapide que la simulation. Si le pas de temps du simulateur est plus long que celui du serveur, alors ce dernier passe en attente jusqu'au pas de temps suivant du simulateur. Ceci évite d'envoyer des données inutiles, car strictement équivalentes.
	
	Le client n'utilise que le protocole TCP pour communiquer avec le serveur. En effet, ne communiquant que très peu, et pour des informations importantes qui ne seront pas répétées, l'UDP n'est pas adapté. Le Tableau \ref{tabClientServ} récapitule les formats et effets des différentes requêtes du client vers le serveur. Ces requêtes permettent de contrôler la simulation ainsi que d'influer sur le modèle multi-agents en fonction des actions de l'utilisateur.
	
	
	\begin{table}
		\begin{tabularx}{\textwidth}{|l|l|X|}
		\hline
		\textbf{Mot Clé }& \textbf{Donnée(s)} & \textbf{Effets}\\
		\hline
		STARTUDP & - & Demande au serveur de démarrer le flux de données.\\
		\hline
		RESTART & - & Demande au serveur de redémarrer la simulation.\\
		\hline
		CLOSE & - & Demande au serveur d'interrompre le flux de données, ainsi que la connexion.\\
		\hline
		FFWD & x & Demande à débrider le serveur pour "x" pas de temps.\\
		\hline
		FrUP & Id & Signale au serveur que l'utilisateur vient de saisir le cadre numéroté "Id".\\
		\hline
		FrDOWN & Id, pos, sens & Signale au serveur que l'utilisateur vient de replacer dans la ruche le cadre numéroté "Id", à la position "pos". La commande indique aussi si le cadre a été retourné, avec le booléen "sens".\\
		\hline
		FrHIT & Id & Signale au serveur que l'utilisateur vient de frapper le cadre numéroté "Id".\\
		\hline
		REBASE & target, {combIds} & Demande au serveur de prendre en compte la division réalisée par l'utilisateur, en gardant la colonie source ou destination selon "target", ainsi que la liste des identifiants des cadres "combId" à conserver.\\
		\hline
		Deaths & - & Demande au serveur la liste des agents morts depuis la dernière requète "Deaths".\\
		\hline
		\end{tabularx}
	\caption{Tableau récapitulant les messages TCP du client vers le serveur, et leurs effets.}
	\label{tabClientServ}
	\end{table}
	
	\subsection{Traitement}
	Le serveur gère ses envois via un composant logiciel réseau communiquant avec le contrôleur principal de la simulation. Le composant réseau récupère ainsi régulièrement les différents états de la simulation, et les envoie. Lors de la réception d'une requête client, la réponse est construite et immédiatement envoyée.
	
	L'application interactive possède de son côté un autre composant réseau permettant d'interpréter les commandes et les rediriger vers les composants logiciels concernés. Ces échanges de messages réseaux, synthétisés Figure \ref{VRThreads}, amènent une grande part d'asynchronie, nous imposant de travailler sur différents \textit{threads}. Les messages sont reçus sur un \textit{thread} dédié, ce qui permet de ne pas bloquer l'ensemble de l'application interactive dans l'attente d'une commande. Ce \textit{thread} se charge ensuite d'interpréter le mot clé ainsi que le paramètre, afin de mettre en forme les données, qui sont jusque-là des chaines de caractères. Une fois remises en forme, elles sont redirigées vers le \textit{thread} principal en utilisant une liste synchronisée dédiée à chaque type de commande. Ces listes, visibles sur la Figure \ref{VRThreads}, sont remplies par le \textit{thread} réseau, mais sont lues par le \textit{thread} principal, à intervalles réguliers. 
	Si aucun message n'a été reçu depuis le dernier pas de temps, certaines listes seront vides alors que l'application essaye de les lire. Ceci est symbolisé par un point d'interrogation après les "données" renvoyées par ces listes sur la Figure \ref{VRThreads}. Ces listes sont alors simplement ignorée pour ce pas de temps. 
	Un système de verrou a été mis en place afin d'éviter que le \textit{thread} principal n'accède à une liste alors qu'elle est en train d'être mise à jour. Dans ce cas le \textit{thread} principal n'a pas accès à la liste, elle sera lue lors du prochain passage.
	
	\begin{figure}
		\includegraphics[width=\textwidth]{Pictures/Figures/Archi-VRThreads}
		\caption{Diagramme de séquence UML décrivant l'envoi de messages par le serveur ainsi que le traitement de ces messages par l'application interactive.}
		\label{VRThreads}
	\end{figure}
	
	Ainsi nos messages asynchrones sont reçus, mis en forme, et transférés au \textit{thread} principal, afin d'être traités de manière synchrone. Les messages envoyés par le client vers le serveur le sont sur le \textit{thread} principal.
	
	\subsection{Modélisation et Visualisation 3D de la Colonie}		
	
	
		Un composant logiciel de l'application interactive, appelé "Ruche", collecte et rassemble toutes les informations provenant du simulateur. Les agents sont rangés dans une liste et possèdent quelques attributs, comme leur dernière tâche en cours ou leur âge. Ils sont bien moins complexes que leurs homologues du simulateur. La ruche possède un autre composant logiciel, un gestionnaire de cadres, permettant l'affichage des agents, via la gestion des différents cadres. Chaque cadre est ainsi représenté par un modèle 3D, et possède un nuage de points représentant les agents qu'il héberge. Lorsqu'un agent change de cadre dans la simulation, il doit être retiré du nuage de points du cadre d'où il vient dans la visualisation, et ajouté au nouveau. Ceci est possible grâce à l'utilisation de dictionnaires "clé-valeur", où chaque agent est rangé en tant que valeur et a pour clé son numéro d'identifiant. 
		Chaque nuage de points possède d'autres identifiants pour référencer ses différents points, c'est pourquoi nous avons dû créer un dictionnaire supplémentaire servant de transition entre les identifiants d'abeilles et les identifiants de points. Ainsi nous savons quel point supprimer afin de supprimer un agent précis.
		
		Ces nuages de points sont des listes de positions 3D correspondant à chacune à un emplacement d'abeille virtuelle. Le nuage de points est ensuite rendu visible par un "\textit{Shader}" spécial, indiquant au moteur graphique de créer de nouvelles formes autour de chacun de ces points\footnote{Le \textit{Shader} par défaut d'Unity3D propose un rendu pour nuage de points, mais ne dessine ces points que sous leur forme de "point mathématique", sans volume.}. Ainsi, pour chaque sommet nous dessinons ici un cube créé à partir de nouveaux points calculés à partir du point d'origine, que nous plaçons au centre. Il est ainsi possible de définir et modifier au cour de l'exécution du programme la position, la taille, mais aussi la couleur de chacun de ces cubes, ce dont nous nous servons pour un premier niveau de visualisation augmentée. De plus, même si nous ne nous en servons pas dans ces travaux, il est possible d'altérer la forme associée à chacun des points pendant l'exécution de l'application.
		
		Afin d'aider l'utilisateur à y voir un peu plus clair dans tous ces points répartis dans différents nuages, les agents sont colorés selon leur taux d'Hormone Juvénile (HJ). Un agent avec un taux d'HJ inférieur à 0.5 (une nourrice) est dessiné en rouge, et un agent avec un taux d'HJ supérieur à 0.5 (une butineuse) sera dessiné en jaune (ce seuil correspond à celui du simulateur, dans celui-ci, un agent sous le seuil ne peut pas butiner, et un agent au dessus ne peut pas nourrir le couvain). La reine quant à elle est dessinée en blanc. La reine n'est pas détectée par la simulation tant qu'elle n'a pas pondu. Dès qu'une abeille, dans une mise à jours de statut, est notée comme étant en train de pondre, elle est classée en tant que reine et sera dessinée en blanc pour le reste de l'exécution de l'application interactive. Seule la reine peut pondre dans cette version du simulateur, cette méthode sera donc à revoir lorsque dans une future version du modèle les ouvrières seront capables de pondre, comme dans de rares cas dans la réalité.
		
		\paragraph{}
		Nous obtenons ainsi autant de nuages de points que nous avons de cadres, et autant de points qu'il y a d'agents. Lors de la réception des positions des agents dans la simulation, une nouvelle position est générée, conservant les coordonnées X et Y, mais plaçant l'identifiant du cadre à l'axe Z. Ainsi nous pouvons retrouver où afficher un agent, et détecter un changement de cadre lorsque la coordonnée en Z change d'une mise à jour à l'autre. Les agents en butinage sont placés de la même manière, avec un identifiant de cadre égal à -1, tout comme leurs coordonnées X et Y. Les agents sur le cadre -1 sont alors affichés sur un nouveau nuage de points, lié à aucun cadre, volants aléatoirement autour de la ruche. De la même manière, lorsqu'un changement de cadre est détecté, les points sont ajoutés et supprimés des nuages correspondants. Afin de lisser le déplacement des agents, la position de chaque point est interpolée de manière linéaire entre sa position précédente et la nouvelle position reçue sur le réseau. Ainsi la visualisation, du fait de l'interpolation, est légèrement en retard par rapport à la simulation : un agent venant d'atteindre la case (X, Y) dans la simulation ne fera que commencer son trajet vers cette case (X, Y) dans la visualisation. La durée de l'interpolation est calibrée sur les pas de temps du serveur, de manière à ce qu'un agent arrive à son point de destination au moment où sa position suivante arrive par le réseau.
	
	\begin{figure}
		\centering
		\includegraphics[width=.5\textwidth]{Pictures/ScreenShots/Frame.JPG}
		\caption{Modélisation d'un cadre, et visualisation d'une de ses faces, avec ses cellules et les agents présents.}
		\label{PicFrame}
	\end{figure}
		
		\paragraph{}
		Les cadres sont chacun représentés par un modèle 3D, mais les cellules sont plaquées sur chacune de leurs faces sous la forme d'une texture, visible sur la Figure \ref{PicFrame}. Cette texture est modifiée régulièrement, seulement aux endroits qui ont été modifiés, afin de suivre l'état de la simulation. Un nuage de points était utilisé auparavant, mais ce dernier n'était pas encore optimisé et il a donc été décidé de changer de méthode. Les nuages de points ont par la suite été optimisés, nous ne savons donc pas si la méthode de la texture apporte un avantage par rapport à cette nouvelle version des nuages de points, utilisée pour les agents. La texture est dessinée en fonction de l'identifiant de contenu reçu par le réseau. Un 0 signifie que la cellule est remplie de nourriture, un 1 indique un œuf, une larve ou une nymphe, et -1 indique une cellule vide. De cette manière différents contenus peuvent être ajoutés par la suite. Le code reçu donne sa couleur à la cellule, et son opacité dépend de la quantité présente dans la cellule. Assez explicite pour de la nourriture, cette quantité nous permet aussi de transmettre l'âge de l'agent infantile. La texture est ensuite dessinée en peignant des disques de ces couleurs au centre des cellules. Nous n'avons donc pas d'hexagones, pourtant emblématiques de la ruche, mais la quantité de cercles présents permet d'obtenir un effet similaire pour une complexité algorithmique moindre dans notre cas.
	
	
	\section{Interactions au Clavier et à la Souris}
		La première version d'interactions avec la ruche a été réalisée avec les interfaces classiques, clavier, souris et écran, même si ces interfaces ne correspondent pas au cas d'utilisation final que nous souhaitons. En effet, une version clavier/souris de l'application interactive permet de toucher un public plus large qu'en nécessitant un équipement plus avancé.
		
		Nous avons donc opté pour une interaction classique que nous retrouvons régulièrement, surtout dans les jeux vidéo. L'utilisateur contrôle un avatar à l'aide de son clavier, qu'il déplace dans l'environnement virtuel. L'avatar ne possède pas de modèle 3D, l'utilisateur voit comme "à la première personne", à travers les yeux virtuels de son avatar. Un viseur se trouve au centre de l'écran, et permet d'interagir avec l'environnement au clic de la souris. Lorsque l'utilisateur effectue un clic gauche, le moteur 3D trace alors une ligne partant de la caméra passant par ce viseur afin de retrouver avec quoi l'utilisateur souhaite interagir. Lorsque rien n'est trouvé, rien ne se passe. Quand un objet permettant l'interaction est détecté, alors l'interaction est lancée. Ici, ce sont les cadres de la ruche avec lesquels nous pouvons interagir.
		
		Lorsque l'utilisateur interagit avec un cadre, la requête "\textit{FrUP}" est envoyée au serveur (que nous retrouvons dans la Table \ref{tabClientServ}) et le cadre est détaché de la ruche et placé dans "les mains" de l'utilisateur. Ce cadre va désormais suivre tous ses mouvements. Une touche est associée avec la commande pour "frapper" le cadre, permettant d'en faire tomber les abeilles virtuelles. Dans la réalité il est important de réaliser cette action avec le cadre au dessus de la ruche, sinon les abeilles ne sachant par encore voler sont perdues. Nous n'avons pour l'instant pas mis en place ce mécanisme dans le simulateur. Les agents qui chutent sont replacés aléatoirement sur les autres cadres présents dans la ruche.
		L'utilisateur peut éloigner ou rapprocher le cadre de sa caméra et le faire pivoter sur ses 3 axes à l'aide de 6 touches de clavier, deux touches par axe, une négative et une positive. Par exemple, une touche permet de faire pivoter le cadre autour de son axe vertical vers la gauche, et une autre sur le même axe mais vers la droite. De cette manière l'utilisateur peut observer avec attention le contenu du cadre.
		
		Pour replacer le cadre dans la ruche, l'utilisateur doit l'approcher de l'emplacement où il souhaite le mettre, puis faire un clic gauche. Une fois assez proche, l'application placera un cadre "fantôme" rouge, permettant à l'utilisateur de savoir qu'en lâchant le cadre, ce dernier ira prendre la place du cadre fantôme. En effet, il est assez compliqué de replacer le cadre correctement une fois l'avoir fait pivoter dans les 3 directions, c'est pourquoi nous avons mis en place cette aide. Il est ainsi possible de replacer un cadre précisément à l'emplacement que l'on souhaite. Lâcher le cadre alors que le cadre fantôme n'est pas apparu le laissera flotter là où il a été lâché. La commande signalant au serveur la pose du cadre ne se fait que lorsque celui-ci est replacé dans la ruche.
		
		 Le Tableau \ref{tabTotalInterClient} récapitule l'ensemble des messages réseaux que le client envoi au serveur, et y décrit comment chaque message est déclenché par l'utilisateur. La colonne "Clavier-Souris" concerne les interactions que nous avons décrits ici. La colonne "Tangible et Manette" concerne la Section \ref{InterTangible}.
	
	\begin{table}
		\begin{tabularx}{\textwidth}{|l|p{4.5cm}|X|}
		\hline
		 & \multicolumn{2}{c|}{\textbf{Interaction Source}}\\
		 \hline
		 \textbf{Commande} & \textbf{Clavier-Souris} & \textbf{Tangible et Manette}\\
		 \hline
		 STARTUDP & \multicolumn{2}{c|}{Démarrage de l'application}\\
		 \hline
		 RESTART & Clic du bouton "Redémarrer" & Non-Implémenté.\\
		 \hline
		 CLOSE & \multicolumn{2}{c|}{Fermeture de l'application}\\
		 \hline
		 FFWD & Clic d'un des boutons d'accélération. & Appui sur un des boutons virtuels d'accélération du bouton principal.\\
		 \hline
		 FrUp & Clic gauche en visant un cadre lorsqu'aucun cadre n'est déjà manipulé. & Pression du bouton secondaire de la manette dans le mode "cadre" lorsque le cadre physique se superpose à un cadre virtuel et ne "contient" pas déjà un cadre virtuel.\\
		 \hline
		 FrDOWN & Clic gauche lorsqu'un cadre est manipulé, et qu'il est suffisament proche d'un emplacement libre de la ruche. & Pression du bouton secondaire de la manette dans le mode "Cadre" lorsque le cadre physique "contient" un cadre virtuel et qu'il se superpose à un emplacement libre de la ruche.\\
		 \hline
		 FrHit & Pression de la touche "F" lorsqu'un cadre est manipulé. & Non-Implémenté.\\
		 \hline
		 REBASE & Clic du bouton correspondant. & Pression sur un des deux cadrans correspondants du bouton principal de la manette en mode "Cadre".\\
		 \hline
		 Deaths & \multicolumn{2}{c|}{Message indépendant des actions de l'utilisateur.}\\
		 \hline 
		\end{tabularx}
	\caption{Tableau récapitulant les messages TCP du client vers le serveur, et les interactions que réalise l'utilisateur pour déclencher leur envoi.}
	\label{tabTotalInterClient}
	\end{table}
		
		
		
	\section{Interactions Immersives}
	\label{immersionSansTangibles}
		Nous avons ensuite travaillé sur un mode d'interactions en environnement immersif. L'utilisateur utilise alors un casque de réalité virtuelle \textit{Oculus Quest 2} et les manettes associées, afin de visualiser et d'interagir avec l'environnement 3D.
		
		 L'utilisateur se déplace dans l'application interactive en se déplaçant physiquement. L'interaction avec les cadres se fait via les manettes. L'utilisateur va placer ses mains (et donc ses manettes), de manière à ce que les représentations de ses manettes dans l'environnement se superposent à la partie supérieure du cadre. Il peut alors maintenir appuyé un bouton par manette afin de saisir le cadre, qui suivra désormais les mouvements de ses mains. Replacer un cadre dans la ruche est assez proche de la version Clavier Souris. L'utilisateur doit placer le cadre suffisamment proche de l'emplacement où il souhaite l'insérer, et le lâcher. Le cadre ira alors se placer automatiquement à l'emplacement libre le plus proche. Les autres fonctionnalités d'interactions sont obtenues via différents boutons sur les manettes.
		
		Cette version de l'application interactive a été développée dans le cadre d'un stage de M2 dans le but de servir de support à une évaluation, dont nous parlerons dans le \textit{Chapitre \ref{ChapitreEvalVR}}. Pour les besoins de l'expérimentation, l'application lit directement des \textit{logs} de simulation déjà générés. Ainsi, les communications réseaux de cette version ainsi que les différents outils permettant de les gérer n'ont pas été intégrés. L'utilisateur interagit avec son environnement, mais les interactions ne sont pas envoyées au simulateur. La manipulation des cadres se fait à des fins purement pédagogiques et la lecture des \textit{logs} permet la visualisation de données de la simulation. 
		
		
	\section{Interactions Naturelles et Immersives}
	\label{InterTangible}
	
	Ce mode d'interaction est une des contributions principales de ces travaux. Afin de proposer des moyens d'interactions naturels avec la simulation multi-agents, nous proposons ici d'utiliser des interacteurs tangibles, dont nous avons décrit les avantages dans le Chapitre \ref{ChapitreEAVR}. L'utilisateur porte un casque de réalité virtuelle, l'immergeant dans l'environnement 3D.

		\subsection{Le Cadre et la Ruche Traqués}		
		
		\begin{figure}
		\centering
		\includegraphics[height=.28\textheight]{Pictures/trackedHiveAfar.JPG}
		\includegraphics[height=.28\textheight]{Pictures/trackedHiveFrame.JPG}
		\caption{Photographies de la ruche et du cadre traqués.}
		\label{photoTracked}
		\end{figure}	
		
		Nous plaçons dans l'environnement physique de l'utilisateur une ruche bien réelle, contenant un unique cadre spécial. Ce cadre et la ruche sont "traqués" : via quelques cibles infrarouges placées dessus (et une série de caméras \textit{OptiTrack} réparties dans la salle, dont les données sont traitées par un autre PC et communiquée à l'application via le réseau), leurs positions et rotations sont en permanence connues de l'ordinateur. La Figure \ref{photoTracked} présente deux photographies des objets traqués, dont nous pouvons voir les différentes cibles infrarouges. Nous pouvons ainsi superposer la ruche virtuelle présente dans l'application interactive à la ruche physique, après de rapides calibrations. De la même manière, le cadre traqué possède une représentation virtuelle superposée, ce qui permet à l'utilisateur de saisir le cadre physique en ne voyant que sa représentation dans l'environnement virtuel. Cette calibration est due au fait que nous utilisons ainsi deux systèmes de \textit{tracking} différents : celui du casque, permettant d'obtenir les positions et rotations de la tête de l'utilisateur ainsi que de ses mains, et le \textit{tracking OptiTrack} pour la ruche et le cadre. Ses différents systèmes n'ont alors pas le même point d'origine, ainsi l'un des deux doit être "recalé" sur l'autre, permettant de corriger les écarts et superposer les points d'origines.
		
		La représentation virtuelle du cadre physique est facilement différentiable des cadres virtuels de la simulation dans l'environnement 3D : il est creux et blanc, là où les autres présentent des alvéoles et sont couleur bois.
		
		L'utilisateur a tout de même besoin d'une manette pour réaliser ces interactions, s'en passer fait partie de nos perspectives.	
		
		\subsection{La Manette}		
		Afin de ne pas trop gêner l'utilisateur lors de ses manipulations, les différentes interactions se trouvent toutes sur une seule manette, permettant de tenir le cadre physique de l'autre main. Le nombre limité de boutons que propose la manette nous a poussé à mettre en place un système de modes, permettant de varier les effets des boutons. Cette méthode permet d'ajouter de nouveaux modes par la suite au besoin. 		
		Le bouton principal de la manette que nous utilisons, la manette du \textit{HTC Vive}, est aussi une surface tactile. Ainsi, nous pouvons détecter la position du doigt de l'utilisateur sur le bouton lors de l'appui. Ceci nous permet de diviser ce bouton en différents cadrans (ou sections), et créer plusieurs boutons virtuels. Nous pouvons de ce fait utiliser un nombre très limité de boutons de la manette, permettant aux utilisateurs de se familiariser rapidement avec la manette et ses fonctionnalités. 
		
		Trois modes ont été implémentés pour cette version :		
		\begin{enumerate}
			\item mode Cadre : le bouton principal permet de réaliser une division. Le bouton secondaire permet de saisir et de lâcher les cadres virtuels à l'aide du cadre physique;
			\item mode Temps : le bouton principal divisé en plusieurs cadrans permet d'accélérer la simulation pour différents temps définis;
			\item mode Visualisation : le bouton principal ainsi que la position de la manette permettent de manipuler le "Graph3D", nous parlerons de ce mode et du "Graph3D" dans la Section \ref{Manip3D}.
		\end{enumerate}
		
		La Figure \ref{ManetteVR} illustre la vision de la manette par l'utilisateur dans chacun de ces trois modes. On y observe notamment le bouton principal divisé en quatre cadrans, différenciés par des couleurs tranchées. Un autre bouton de la manette, au dessus du bouton principal, permet de faire défiler les modes les uns à la suite des autres. Un texte flottant au dessus de la manette permet à l'utilisateur de rapidement identifier le mode courant. De plus, des textes et couleurs sont plaqués sur la manette, s'adaptant aux différents modes afin de toujours refléter la fonction du bouton. Le bouton principal ainsi que le bouton de mode sont utilisés avec le pouce, le bouton secondaire est une gâchette généralement actionnée avec l'index.
		
		\begin{figure}
		\centering
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVR.JPG}
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVRFrame.JPG}
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVRGraph.JPG}
		\caption[Manette vue par l'utilisateur, respectivement en mode Temps, Cadre et Visualisation.]{Manettes vue par l'utilisateur, respectivement en modes Temps, Cadre et Visualisation. On observe le bouton principal divisé en quatre cadrans, transformant ce bouton unique en quatre boutons "virtuels".}
		\label{ManetteVR}
		\end{figure}
		
		\subsection{Manipulation des Cadres}		
		
			
		Afin de saisir un cadre, l'utilisateur vient superposer le cadre physique avec un des cadres virtuels présents dans la ruche. Ensuite, appuyer sur le bouton secondaire de la manette va venir plaquer le cadre virtuel ainsi sélectionné sur le cadre réel. L'utilisateur manipule désormais directement le cadre virtuel tiré de la simulation via son cadre physique. La Figure \ref{equiVRTUI} présente à gauche un utilisateur manipulant le cadre physique auquel un cadre virtuel est attaché, et à droite ce que voit l'utilisateur dans l'environnement virtuel : le cadre physique est modélisé par le cadran blanc qui ici contient le cadre virtuel manipulé, sur lequel nous pouvons observer quelques abeilles de la simulation. L'utilisateur peut ainsi orienter facilement le cadre virtuel et l'observer de toute part de manière naturelle, comme nous le ferions avec n'importe quel objet réel. Un nouvel appui du bouton secondaire fera lâcher le cadre virtuel qui restera à flotter dans l'air. Si le cadre virtuel est lâché alors que le cadre manette est superposé à un emplacement vide dans la ruche, alors le cadre virtuel y est inséré et le serveur est prévenu.	

	\begin{figure}
	\centering
	\includegraphics[height=0.23\textheight]{Pictures/HeldFramePic.JPG}
	\includegraphics[height=0.23\textheight]{Pictures/ScreenShots/HeldFrame.JPG}
	\caption{Manipulation du cadre physique, et vue de l'utilisateur dans l'environnement virtuel.}
	\label{equiVRTUI}
	\end{figure}
		
		Pour réaliser une division, l'utilisateur a deux possibilités, matérialisées sur deux des quatre cadrans du bouton principal. La division consiste à séparer la ruche en deux, et se concentrer ensuite sur l'une de ces deux nouvelles colonies. Une fois que l'utilisateur a sorti une certaine quantité de cadres, il peut choisir de réaliser la division. Les cadres à l'intérieur de la ruche formeront une nouvelle colonie, ainsi que tous ceux qui sont à l'extérieur. L'utilisateur doit donc choisir quelle ruche il désire suivre, l'ancienne ou la nouvelle. La manette propose ainsi de "Jeter" les cadres présents dans la ruche initiale, ou de les "Garder" et de jeter les autres, comme illustré dans la Figure \ref{ManetteVR}. Le tableau \ref{tabTotalInterClient} récapitule les différents messages que le client envoie au serveur. Sa colonne "Tangible et Manette" décrit comment l'utilisateur déclenche ces envois dans le cas que nous décrivons ici.

		\paragraph{}		
		Pour une future version de ce moyen d'interaction, nous avons pensé équiper le cadre physique d'un bouton, afin de pouvoir saisir et lâcher les cadres virtuels sans avoir besoin de la manette. Ce bouton remplacerait alors le bouton secondaire de la manette, la gâchette. Ceci permettrait de manipuler les cadres à deux mains, comme le font les apiculteurs. En effet, si les cadres vides et sans cire sont légers, les cadres bâtis (constitués d'alvéoles de cire) et remplis de miel peuvent facilement peser jusqu'à 4 kilogrammes.
		
		Une autre possibilité d'amélioration pour cette interaction est de diminuer la taille des cibles infra-rouge. En effet, leur taille nous empêche de traquer plusieurs cadres sans que ceux-ci ne se gênent pour ensuite rentrer dans la ruche. De plus petits capteurs permettraient de traquer l'ensemble des cadres de la ruche, rendant la manipulation encore plus naturelle. Il sera alors nécessaire de détecter lorsque l'utilisateur saisit et lâche un cadre via les mouvements et positions des cadres, puisque des pressions de boutons ne seront plus nécessaires.
		
		Quelques prototypes de ces deux propositions ont été réalisés, mais beaucoup de travail reste à faire.
		
		Frapper un cadre se fait par l'appui d'un autre bouton sur la manette. En effet, nos premiers essais de détection de frappe sur le cadre via le \textit{tracking} (changements brusques de vitesses) nous donnaient des comportements trop imprévisibles. En effet, les données sont bruitées et le coup sec que les apiculteurs donnent au cadre pour en faire tomber les abeilles est difficile à isoler. Nous pensons intégrer une centrale inertielle au cadre afin de ne pas détecter le choc via les caméras, mais directement depuis le cadre. Il serait peut être possible d'utiliser les données du \textit{tracking} en y appliquant un traitement adapté.
		
		\subsection{Manipulation du Temps}
		
		Pour manipuler le temps, le bouton principal est divisé en quatre cadrans. Trois de ceux-ci présentent différents temps d'accélération prédéfinis : 7 jours, 1 jour et 5 heures, visibles sur la Figure \ref{ManetteVR} à gauche. L'intervalle de 7 jours correspond en général à la fréquence des visites de ruches de la part d'apiculteurs, les autres ont été choisis arbitrairement. Le troisième cadran "Stop" permet à l'utilisateur d'interrompre l'avance rapide, demandant au serveur de repasser en temps réel sans attendre d'avoir fini la précédente requête d'accélération. Envoyer une nouvelle requête efface/remplace la précédente, les durées d'accélération ne s'additionnent donc pas. Par exemple, le bouton Stop demande en réalité au serveur une avance rapide de zéro pas de temps, ce qui a pour effet de stopper toute avance rapide alors engagée. En effet, peut importe le nombre de pas de temps restant à l'avance rapide précédemment engagée, ce nombre sera remplacé par zéro, mettant instantanément fin à l'avance rapide.
		
	\section{Un Graphique 3D pour Visualiser et Comprendre l'Auto-Organisation}
	\label{Manip3D}
		Dans le but d'offrir une visualisation mettant en valeur les mécanismes de l'auto-organisation au sein de la colonie d'abeilles, nous proposons d'utiliser un graphique en 3 dimensions (sur 3 axes), sobrement surnommé le "\textit{Graph3D}". Comme nous l'avons vu dans la Section \ref{sectionVisuComplexe}, nous cherchons ici à obtenir une visualisation abstraite du système, afin d'y confronter directement l'utilisateur et de mettre en valeur les mécanismes et effets de l'auto-organisation.
		
		\subsection{Fonctionnement du Graph3D}
		
		Pour reprendre simplement ce que nous avons vu dans le \textit{Chapitre \ref{ChapitreContexte}} ainsi que dans le \textit{Chapitre \ref{ChapitrePropSMA}}, les abeilles, via leurs phéromones, altèrent leur âge physiologique. Cette altération devient visible car cet âge physiologique se décorrèle de leur âge réel. Nous proposons donc de placer chacun de ces indicateurs sur un axe, et de positionner ensuite chaque agent de la simulation en un point du volume ainsi formé. Les agents sont positionnés dans le Graph3D en utilisant un nuage de points semblable à ceux utilisés pour les placer sur les cadres. Nous y retrouvons, pour faciliter la lecture, la redondance de l'information de l'âge physiologique sous la forme de la couleur des points. Tous les agents au delà de $\frac{1}{2}$ sur l'axe de l'âge physiologique seront visualisés en jaune, les autres en rouge.
		La Figure \ref{Graph3D} illustre le Graph3D dans le cas d'une colonie classique respectant le polyéthisme d'âge (\ref{Graph3DStd}), et dans le cas théorique d'une colonie peu après une division (\ref{Graph3DDiv}). Dans le premier cas l'âge physiologique et l'âge réel sont proches, les agents âgés butinent (en jaune en haut à droite) et les jeunes s'occupent du couvain (en rouge en bas à gauche). Dans le cas de la division, l'interruption de la ponte liée à la perte de la reine provoque un grand déséquilibre dans la répartition des âges au sein de la colonie. Nous nous attendons ainsi à observer de jeunes agents partir butiner plus tôt, c'est pour ceci que nous observons sur la Figure \ref{Graph3DDiv} des cubes jaunes (physiologie de butineuse) dans la moitié gauche du Graph3D, contenant les jeunes agents.
		
		Le troisième axe, celui dédié aux échanges de phéromones, permet comparativement de comprendre pourquoi certains agents partent butiner plus tôt que d'autres. Les agents partant butiner plus tôt sont ceux ayant le moins échangé de phéromones, censées les faire rester physiologiquement jeunes. Ainsi, plus un agent est loin sur l'axe des phéromones échangées (plus il est petit sur la figure), plus il aura échangé de phéromones, plus il aura un âge physiologique faible. Cette donnée est obtenue en additionnant l'ensemble des échanges de chaque agent avec les autres, en valeur absolue. Ainsi, donner une certaine quantité de phéromones, ou recevoir cette même quantité aura le même impact sur cette valeur. Pour mieux représenter la réalité, cette somme est multipliée à chaque pas de temps par un coefficient légèrement inférieur à 1, afin de minimiser progressivement l'impact d'échanges passés.
		
	\begin{figure}
	\centering
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.8\textwidth]{Pictures/Graphs/Graph3DStd.png}
	\caption{}
	\label{Graph3DStd}	
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.8\textwidth]{Pictures/Graphs/Graph3DDiv.png}
	\caption{}
	\label{Graph3DDiv}
	\end{subfigure}
	
	\caption[Notre \textit{Graph3D} et ses trois axes.]{Notre \textit{Graph3D} et ses trois axes. Chaque cube représente un agent. La couleur du cube est une redondance de l'âge physiologique, rouge lorsqu'il est inférieur à $\frac{1}{2}$, jaune sinon. Une cube plus petit représente un cube plus loin sur l'axe de la profondeur, donc ici un agent qui aurait échangé plus de phéromones. Dans le cas d'une colonie standard, nous nous attendons à trouver le Graph3D sous la forme (a), dans le cas d'une division nous nous attendons plutôt à la forme (b).}	
	\label{Graph3D}
	\end{figure}
	
	\subsubsection{Échelles des Axes}
	L'axe du Graph3D représentant l'âge physiologique représente directement le taux d'HJ des agents, qui est compris dans $[0;1]$ dans la simulation. Il est donc simple de répartir les points sur cet axe.
	
	Les deux autres en revanche, ne sont pas bornés. Aucun agent ne va mourir au même âge, à cause de la pénalité causée par le butinage. Plus un agent butine, plus il va mourir jeune. De même pour les échanges de phéromones, chaque agent en possède une valeur unique, une somme pondérée qu'il est difficile de borner. Nous savons toutefois que ces deux valeurs sont forcément positives. Nous avons donc proposé deux modes de représentation, sans avoir à ce jour décidé lequel utiliser, d'autres seraient peut-être plus adaptés. Un mode relatif "instant t", où l'agent avec la valeur la plus élevée est placé à l'extrémité de l'axe, et la position des autres en est déduit linéairement. Un mode relatif "absolu" fonctionnant de la même manière que le précédent, mais en prenant en compte l'ensemble de la simulation. Ainsi, un agent à l'extrémité d'un axe possède la valeur sur cet axe la plus élevée de toute la simulation.
	
	De plus, afin d'améliorer la perception des faibles valeurs de l'axe des échanges de phéromones, les positions sur cet axe sont sur une échelle logarithmique.
	
	\subsubsection{Mise en Valeur des Interactions}
	Afin de rendre compte des interactions entre agents, nous avions proposé de relier, dans le Graph3D, des agents interagissant entre eux. Nous avons rapidement abandonné cette idée : les agents interagissent sur une échelle de temps bien plus courte que les changements physiologiques que ces interactions induisent. En effet, là où les échanges entre agents se produisent à l'échelle de la seconde, les changements physiologiques se produisent sur quelques jours. Tracer ces lignes dans le Graph3D provoque un bruit conséquent dans la visualisation du Graph3D, et n'apporte rien de plus que la position des agents sur l'axe des échanges de phéromones. Nous retrouvons ici un des problèmes inhérents à la visualisation de systèmes complexes, les différences de granularité entre différentes notions de ce système \cite{hutzler_du_2000}.
	
	\subsection{Manipulation du Graph3D}
	
		Équipé d'un casque de réalité virtuelle, l'utilisateur peut manipuler le graphique à l'aide d'une manette. Le Graph3D possède des ancres de rotation, et appuyer sur un des quatre cadrans du bouton principal (dans le bon mode) sélectionne l'une de ces rotations. Lors de la sélection, le Graph3D vient se placer juste au dessus de la manette, dans la rotation souhaitée. L'utilisateur peut aussi appuyer sur le bouton secondaire de la manette afin de "saisir" le graphique. Une fois saisi, le graphique est "fixé" sur la manette, ainsi les mouvements de poignets de l'utilisateur déplaceront le graphique, en position comme en rotation. Cette méthode de manipulation permet de percevoir correctement les trois axes du Graph3D, du fait de la stéréoscopie offerte par le casque de réalité virtuelle. De plus, cette méthode de manipulation permet une interaction naturelle avec l'objet de visualisation, en effet, la manipulation du graphique s'effectue de la même façon que la manipulation d'objets réels, comme nous l'avons vu dans le \textit{Chapitre \ref{ChapitreEAVR}}.
		
	
	
			
	\section*{Conclusion}
	Dans ce chapitre nous avons présenté notre architecture logicielle. La séparation complète du simulateur et de l'application de visualisation interactive nous offre souplesse et modularité. Nous avons décrit les échanges réseaux de ces deux parties, ainsi que les traitements qu'ils déclenchent. Nous avons passé en revue les différentes modélisations et représentations 3D de l'application, dont l'utilisation de nuages de points pour représenter les agents. Nous avons ensuite décrit les différents moyens d'interactions avec la simulation, depuis l'application interactive, dans différentes versions, pour différents supports, dont notre proposition de l'utilisation d'interacteurs tangibles pour des interactions naturelles.
	Nous avons ensuite présenté notre proposition de visualisation des mécanismes régissant la répartition des tâches au sein de la colonie, sous la forme d'un graphique en trois dimensions, présentant l'état interne de chaque agent de la simulation, dans un nuage de points.
	
	 Nous allons dans le chapitre suivant évaluer l'intérêt du Graph3D ainsi que l'application d'interaction immersive avec manettes, en décrivant l'expérimentation que nous avons mise en place, puis discuter des résultats obtenus et des perspectives qu'ils offrent.
	