\chapter{Propositions : Visualisation et Interactions}
		Nous souhaitons permettre à un utilisateur de pouvoir interagir avec notre simulation multi-agents de la colonie d'abeilles. De manière générale, les apiculteurs manipulent leurs ruches en ne manipulant que les cadres. Ils effectuent parfois certaines actions directement sur les reines, comme la placer dans une petite cage pour limiter ses mouvements, ou tout simplement la retirer et/ou en insérer une nouvelle. Nous ne nous sommes pas pour l'instant intéressés à ces cas particuliers, et avons décidés de permettre à l'utilisateur de manipuler les cadres de la ruche. En effet, déplacer les cadres ou en remplacer par d'autres permet d'altérer fortement l'environnement de la colonie. Les individus la constituant devront alors faire preuve d'auto-organisation afin de s'adapter à ces nouvelle conditions. En plus de provoquer cette réaction d'auto-organisation, nous souhaitons l'observer, et observer en détail les mécanismes qui la provoque.
		
		Nous nous sommes ainsi principalement intéressés au cas de la division. La division est un geste apicole séparant une colonie, dont la population est trop importante, en deux colonies. Une colonie trop populeuse laissée en autonomie va "Essaimer" : les ouvrières vont élever une nouvelle reine, puis une bonne partie vont la suivre lors de son envol pour former une nouvelle colonie, ailleurs. La division permet à l'apiculteur de prévenir un éventuel essaimage et de garder le contrôle sur les deux nouvelles colonies, au lieu d'en perdre une dans la nature. Pour réaliser une division, les apiculteurs collectent différents cadres et les abeilles présentent dessus, et essayent de diviser en mieux en deux la colonie. Une nouvelle ruche est alors remplie de quelques cadres, en essayant d'y intégrer des abeilles de tout âge, du couvain de tout âge ainsi que différentes ressources. Les proportions doivent être à peu près les même pour la colonie source et la nouvelle colonie, afin de ne pas en condamner une. Une fois séparée, les cadres manquants de chaque ruche sont remplacés par des cadres vides.

	\section{Interactions avec la Simulation}
		
		L'utilisateur devra alors pouvoir interagir avec les cadres, les déplacer ou les retirer de la ruche. Il aura aussi besoin de manipuler la simulation en elle-même à travers ses interactions. Ainsi un utilisateur de notre application sera en mesure d'effectuer plusieurs actions :
		\begin{itemize}
			\item Attraper un cadre
			\item Frapper le cadre manipulé : cette action permet d'en faire tomber les abeilles, afin de pouvoir observer le contenu du cadre. Cette action est presque systématique pour l'apiculteur.
			\item Lâcher le cadre manipulé : soit dans la ruche sur un emplacement de cadre vide, soit à l'extérieur, permettant ainsi de laisser un emplacement vide. Un cadre peut aussi être lâché dans une deuxième ruche, permettant de simuler la division.
			\item Valider la division : cette action importante isole l'une des deux ruches (au choix de l'utilisateur). Les cadres et abeilles alors présents dans l'autre ruche sont retirés de la simulation.
			\item Accélérer le temps : l'utilisateur demande au simulateur de ne plus respecter le temps réel pour un temps donné. Le simulateur alors débridé calcule plus rapidement. Une fois la durée donnée par l'utilisateur atteinte, le simulateur repasse en mode temps réel. L'utilisateur indique un temps en seconde, c'est l'application interactive qui se charge de faire la conversion en pas de temps.
			\item Redémarrer la simulation
			\item Arrêter la simulation, fermer l'application.		
		\end{itemize}
		
		

	\section{Architecture Logicielle}
	
	\subsection{Communications}

	\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{Pictures/Figures/Distrib.png}
	\caption{Architecture du simulateur et de l'application interactive.}{Les deux composants sont totalements séparés et communiquent via le réseau, en utilisant des requêtes UDP ou TCP selon les besoins.}
	\label{archi}
	\end{figure}
	
	
	Nous proposons de séparer la simulation et sa visualisation, suivant les conseils de Louloudi et. al. \cite{louloudi_new_2012}, en utilisant un serveur Java pour exécuter la simulation, et un client \textit{Unity3D} pour la visualisation et les interactions. La Figure \ref{archi} illustre notre proposition. Nous n'utilisons toutefois pas de composant "relai" universel permettant le lien entre les deux parties, comme ils l'ont proposé. Ce rôle est tenu à la fois par un protocole de communication UDP/TCP que nous avons élaboré, et par un composant dédié aux communications dans les deux parties du système. Le simulateur et l'application interactive possèdent chacun une section réseau indépendante, permettant d'envoyer et recevoir des requêtes réseau.
	
	En plus des bénéfices cités par Louloudi et. al. \cite{louloudi_new_2012} et énumérés dans le chapitre prédécent, cette séparation permet de limiter l'impact des contraintes d'un support sur l'autre : contrainte graphique dans la simulation, ou contrainte de simulation dans l'environnement graphique. 	
	
	\begin{table}
		\begin{tabularx}{\textwidth}{|l|l|l|p{2cm}|X|}
		\hline
		\textbf{Fréq} & \textbf{Mot Clé} & \textbf{Param} & \textbf{Donnée(s)} & \textbf{Effets}\\
		\hline
		\multicolumn{5}{|l|}{\textbf{TCP}} \\
		\hline
		- & STARTUDP & - & \{combId\} & La liste des identifiants des cadres de la simulation, en réponse aux STARTUDP et RESTART du client.\\
		\hline
		- & DEATHS & nb & \{agentId\} & La liste des identifiants des agents morts depuis la dernière requête "DEATHS", liste de longueur "nb".\\
		\hline
		\multicolumn{5}{|l|}{\textbf{UDP}} \\
		\hline
		1/2 & AGENTS & combId & \{agentId,\newline X, Y\} & La liste des agents présents sur le cadré numéroté "combId". Ensuite, pour chaque agent, son numéro d'identification "agentId" ainsi que sa position "(X,Y)" sur le cadre.\\
		\hline
		1/4 & FORAGERS & - & \{agentId\} & La liste des identifiants "agentId" de tous les agents à l'extérieur de la ruche.\\
		\hline
		1/20 & CONTENT & combId & \{Nb,\newline contentId,\newline fill\} & Le contenu du cadre numéroté "combId". Les données contiennent ensuite pour chaque cellule du cadre, son numéro "Nb" (lié à sa position), un identifiant "contentId" indiquant le type de contenu et son remplissage "fill".\\
		\hline
		1/4 & STATES & timeStep & \{agentId,\newline age,\newline HJ,\newline phEx\} & Les états courant de tous les agents adultes. À la suite et pour chaque agent la liste contient son identifiant "agentId", son age, son taux d'HJ ainsi que la quantité de phéromones "phEx" que l'agent a échangé.\\		
		\hline
		\end{tabularx}
	\caption{Tableau récapitulant les messages du serveur vers le client, leurs types et leurs sens.}
	\label{tabServClient}
	\end{table}
	
	Les communications du serveur vers le client se font majoritairement via UDP. Ce protocole simple permet l'envoi d'une grande quantité de donnée, mais ne permet pas d'assurer de la bonne réception de ces dernières. Ainsi, nous nous en servons pour transmettre sous la forme d'un flux les différente données de la simulation. En cas de mauvaise réception, il suffit d'attendre la prochaine itération du flux afin de corriger le tir. Ainsi, les positions des agents, leurs âges etc. passent par un flux UDP, formaté sous la forme :	
	\begin{center}
		[Mot Clé] [Paramètre] \{Données\}
	\end{center}
	Cette forme unique nous permet de faciliter le décodage de ces informations à la réception. Un mot clé permet d'orienter rapidement l'application client vers la bonne manière de traiter la suite des données. Ensuite, un paramètre permet de transmettre une information importante, qui n'a pas sa place dans le gros des données. Lorsqu'il n'est pas utilisé, ce paramètre est placé à -1, afin d'éviter que la première donnée soit comptée comme le paramètre. Ensuite les données consistent en une suite de caractères, séparés par des espaces. 
	Le serveur utilise le protocole TCP pour communiquer des accusés de réception au client. Dans deux cas la réponse TCP du serveur est un peu plus complexe. Le premier cas, lors du démarrage ou du redémarrage d'une simulation, le serveur envoie via TCP les identifiants ordonnés des cadres présents, permettant au client d'en connaitre le nombre et leurs positions les uns par rapport aux autres. Le second concerne la mort des agents. C'est en effet une information importante, nous ne voulons pas que le client la rate, car elle ne sera pas renvoyée. Ainsi, les identifiants des agents morts sont communiqués au client via TCP, sur une demande du client. 
	La Table \ref{tabServClient} récapitule les principales communications du serveur vers le client, en omettant les accusés de réceptions simples. Le tableau nous informe aussi de la fréquence des envoi UDP. En effet, afin de ne pas surcharger le client et le réseau, ces informations ne sont pas envoyées systématiquement. Le serveur fonctionne de manière autonome par rapport à la simulation, et possède ses propres pas de temps définis. Les fréquences sont données dans la Table en pas de temps réseau. 
	Toutefois, le serveur est bridé afin de ne pas pouvoir être plus rapide que la simulation. Si le pas de temps de la simulation est plus lent que le serveur, alors celui-ci sera bloqué jusqu'au pas de temps suivant de la simulation. Ceci évite d'envoyer des données inutiles tout en permettant de ne pas envoyer de données à chaque pas de temps du simulateur, ce qui peut poser problème lorsque celui-ci est débridé.
	
	Le client n'utilise que le protocole TCP pour communiquer avec le serveur. En effet, ne communiquant que très peu, et pour des informations importantes qui ne seront pas répétées, l'UDP n'est pas adapté. La Table \ref{tabClientServ} récapitule les formats et effets des différentes requêtes du client vers le serveur. Ces requêtes permettent de contrôler la simulation ainsi que d'influer sur le modèle multi-agents en fonction des actions de l'utilisateur.
	
	
	\begin{table}
		\begin{tabularx}{\textwidth}{|l|l|X|}
		\hline
		\textbf{Mot Clé }& \textbf{Donnée(s)} & \textbf{Effets}\\
		\hline
		STARTUDP & - & Demande au serveur de démarrer le flux de données.\\
		\hline
		RESTART & - & Demande au serveur de redémarrer la simulation.\\
		\hline
		CLOSE & - & Demande au serveur d'interrompre le flux de données, ainsi que la connexion.\\
		\hline
		FFWD & x & Demande à débrider le serveur pour "x" pas de temps.\\
		\hline
		FrUP & Id & Signale au serveur que l'utilisateur vient de saisir le cadre numéroté "Id".\\
		\hline
		FrDOWN & Id, pos, sens & Signale au serveur que l'utilisateur vient de replacer dans la ruche le cadre numéroté "Id", à la position "pos". La commande indique aussi si le cadre a été retourné, avec le booléen "sens".\\
		\hline
		FrHIT & Id & Signale au serveur que l'utilisateur vient de frapper le cadre numéroté "Id".\\
		\hline
		REBASE & target, {combIds} & Demande au serveur d'effectuer la division, en gardant la colonie source ou destination selon "target", ainsi que la liste des identifiants des cadres "combId" à conserver.\\
		\hline
		Deaths & - & Demande au serveur la liste des agents morts depuis la dernière requète "Deaths".\\
		\hline
		\end{tabularx}
	\caption{Tableau récapitulant les messages TCP du client vers le serveur, et leurs effets.}
	\label{tabClientServ}
	\end{table}
	
	Lors d'une avance rapide, le serveur cesse d'envoyer les positions des agents, les agents en butinage ainsi que le contenu des cadres. Ne sont envoyés que les activités des agents, la commande "\textit{STATES}" du tableau \ref{tabServClient}. En effet, en avance rapide, ces informations concernant chaque abeille changent extrêmement rapidement et n'intéressent alors pas l'utilisateur, il n'est donc pas nécessaire de surcharger les communications.
	
	\subsection{Traitement}
	Le serveur gère ses envois grâce à un composant logiciel réseau communiquant avec le contrôleur principal de la simulation. Le composant réseau récupère ainsi régulièrement les différents états de la simulation, et les envoie à son rythme. Lors de la réception d'une requête client, la réponse est construite et immédiatement envoyée.
	
	L'application interactive possède de son côté un autre composant réseau, divisé en plusieurs étapes, permettant d'interpréter les commandes et les rediriger vers les composants logiciels concernés. Tous ces échanges réseaux amènent une grande part d'asynchronicité, nous imposant de travailler sur différent \textit{threads}. Les messages sont reçu sur un \textit{thread} dédié, ce qui permet de ne pas bloquer l'ensemble de l'application interactive dans l'attente d'une commande. Ce \textit{thread} se charge ensuite d'interpréter le mot clé ainsi que le paramètre, afin de mettre en forme les données, qui sont jusque là des chaines de caractères. Une fois remise en forme, elles sont redirigées vers le \textit{thread} principal en utilisant une série de liste synchronisée, une part type de commande. Ces listes sont remplies par le \textit{thread} réseau, mais sont lues par le \textit{thread} principal, à intervalle régulier. Ces files sont alors vidées par le \textit{thread} principal. Une système de verrou a été mis en place afin d'éviter que le \textit{thread} principal n'accède à une liste alors qu'elle est en train d'être mise à jours. Dans ce cas le \textit{thread} principal n'a pas accès à la liste, elle sera lu lors du prochain passage.
	
	Ainsi nos messages asynchrones sont traités, mis en forme, et transférés au \textit{thread} principal, afin d'être traités de manière synchrone. Les messages envoyés par le client vers le serveur le sont sur le \textit{thread} principal.
	
	\subsection{Modèle et Visualisation de la Colonie}
		Un composant logiciel de l'application interactive, appelé "Ruche", collecte et rassemble toutes les informations provenant du simulateur. Les agents sont rangés dans une liste et possèdent quelques attributs, comme leur dernière tâche en cours ou leur âge. Ils sont bien moins complexes que leurs homologues du simulateur. La ruche possède un autre composant logiciel, un manageur de cadre, permettant l'affichage des abeilles, via la gestion des différents cadres. Chaque cadre est ainsi représenté par un modèle 3D, et possède un nuage de point représentant les abeilles qu'il héberge. Lorsqu'une abeille change de cadre dans la simulation, elle doit être retirée du nuage de point du cadre d'où elle vient dans la visualisation, et ajoutée au nouveau. Ceci est possible grâce à l'utilisation de dictionnaire "clé-valeur", où chaque abeille est rangée en tant que valeur et a pour clé son numéro d'identifiant. 
		Chaque nuage de points possède d'autres identifiants pour référencer leurs différents points, c'est pourquoi nous avons du créer un dictionnaire de transition entre les identifiants d'abeilles et les identifiants de points. Ainsi nous savons quel point supprimer afin de supprimer une abeille précise.
		
		Nous obtenons ainsi autant de nuage de points que nous avons de cadres, et autant de points qu'il y a d'abeilles. Lors de la réception des positions des abeilles dans la simulation, une nouvelle position est générée, conservant les coordonnées X et Y, mais plaçant l'identifiant du cadre à l'axe z. Ainsi nous pouvons retrouver où afficher une abeille, et détecter un changement de cadre lorsque la coordonnée en z change d'une mise à jours à l'autre. Les butineuses sont placées de la même manière, avec un identifiant de cadre égal à -1, tout comme leurs coordonnées X et Y. Les abeilles sur le cadre -1 sont alors affichées sur un nouveau nuage de points, lié à aucun cadre, virevoltant aléatoirement autour de la ruche. De la même manière, lorsqu'un changement de cadre est détecté, les points sont ajoutés et supprimés des nuages correspondant. Afin de lisser le déplacement des abeilles, la position de chaque point est interpolée entre sa position précédente et la nouvelle position reçue sur le réseau. Ainsi la visualisation, du fait de l'interpolation, est légèrement en retard par rapport à la simulation : une abeille venant d'atteindre la case X, Y dans la simulation, ne fera que commencer son trajet vers cette case X, Y dans la visualisation. La durée de l'interpolation est calibrée sur les pas de temps du serveur.
		
		\paragraph{}
		Ces nuages de points sont des polygones difformes possédant un sommet à chaque emplacement d'abeille. Le nuage de points est rendu possible par l'utilisation d'un "\textit{Shader}" spécial, indiquant au moteur graphique de ne pas l'afficher comme une polygone normal. Au lieu de chercher à dessiner des triangles entre ces différents sommets, nous indiquons via ce nouveau \textit{Shader} au moteur de créer de nouvelle forme autour de chacun de ces sommets. Ainsi, pour chaque sommet, nous dessinons un cube dont le centre correspond au sommet en question. Il est en plus possible de commander la couleur de ces cubes, pour chacun des points, ce dont nous nous servons pour un premier niveau de visualisation augmentée. Afin d'aider l'utilisateur à y voir un peu plus clair dans tous ces points répartis dans différents nuages, les abeilles sont colorés selon leur taux d'Hormone Juvénile (HJ). Une abeille avec un faible taux d'HJ (une nourrice) est dessinée en rouge, et une abeille avec un fort taux d'HJ (une butineuse) sera dessinée en jaune. La reine quant à elle est dessinée en blanc. La reine n'est pas détectée par la simulation tant qu'elle n'a pas pondu. Dès qu'une abeille, dans une mise à jours de statut, est noté comme étant en train de pondre, elle est classée en tant que reine et sera dessinée en blanc pour le reste de l'exécution de l'application interactive. Nous n'avons en effet que la reine qui peut pondre dans cette itération du simulateur, cette méthode sera à revoir lorsque les ouvrières seront autorisées à pondre aussi, ce qu'elles font dans de rares cas dans la réalité.
		
		\paragraph{}
		Les cadres sont chacun représentés par un modèle 3D, mais les cellules sont plaquées sur leurs faces sous la forme d'une texture. Cette texture est modifiée régulièrement, seulement aux endroits qui ont été modifiés, afin de suivre l'état de la simulation. Un nuage de point était utilisé auparavant, mais ces derniers n'étaient pas encore optimisé et il a donc été décidé de changer de méthode. Les nuages de points on par la suite été optimisé, nous ne savons donc pas si la méthode de la texture apporte un avantage par rapport à cette nouvelle version des nuages de points, utilisés pour les abeilles. La texture est dessinée en fonction de l'identifiant de contenu reçu par le réseau. Un 0 signifie que la cellule est remplie de nourriture, un 1 indique un œuf, une larve ou une nymphe, et -1 indique une cellule vide. De cette manière différents contenus peuvent être ajoutés par la suite. Le code reçu donne sa couleur à la cellule, et son opacité dépend de la quantité présente dans la cellule. Assez explicite pour de la nourriture, cette quantité nous permet aussi de transmettre l'age de l'abeille infantile. La texture est ensuite dessinée en peignant des cercles de ces couleurs au centre des cellules. Nous n'avons donc pas d'hexagones, pourtant emblématiques de la ruche, mais la quantité de cercles présents permet d'obtenir un effet similaire pour un coup moindre.
	
	
	\section{Interaction Clavier Souris}
		La première étape d'interactions avec la ruche a été réalisé avec les interfaces classiques, clavier, souris et écran. Même si ces interfaces ne sont pas le cas d'utilisation final que nous souhaitons, nous y avons tout de même prêté du soin. En effet, une version clavier/souris de l'application interactive permettrai de toucher un publique plus large qu'en nécessitant un équipement plus avancé.
		
		Nous avons donc opté pour une interaction classique que nous retrouvons régulièrement, surtout dans les jeux vidéo. L'utilisateur contrôle un avatar à l'aide de son clavier, qu'il déplace dans l'environnement virtuel. L'avatar ne possède pas de modèle 3D, l'utilisateur voit comme "à la première personne", à travers les yeux virtuels de son avatar. Un viseur se trouve au centre de l'écran, et permet d'interagir avec l'environnement au clic de la souris. Lorsque l'utilisateur effectue un clic gauche, le moteur 3D trace alors une ligne partant de la caméra et passant par ce viseur afin de retrouver avec quoi l'utilisateur souhaite interagir. Lorsque rien n'est trouvé, rien ne se passe. Quand un object permettant l'interaction est détecté, alors l'interaction est lancée. Ici, ce sont les cadres de la ruche avec lesquels nous pouvons interagir. 
		
		Lorsque l'utilisateur interagit avec un cadre, la requête "\textit{FrUP}" est envoyée au serveur (que nous retrouvons dans la Table \ref{tabClientServ}) et le cadre est détaché de la ruche et placé dans "les mains" de l'utilisateur. Ce cadre va désormais suivre tous ses mouvements. Une touche est associé avec la commande pour "frapper" le cadre, permettant d'en faire tomber les abeilles. Dans la réalité il est important de réaliser cette action avec le cadre au dessus de la ruche, sinon les abeilles ne sachant par encore voler son perdues. Nous n'avons pour l'instant pas mis en place ce mécanisme. Les abeilles qui chutent sont replacées aléatoirement sur les autres cadres présents dans la ruche.
		L'utilisateur peut éloigner ou rapprocher le cadre de sa caméra grâce à la molette de sa souris. Il peut aussi le faire pivoter sur ses 3 axes à l'aide de 6 touches de clavier, deux touches par axe, une négative et une positive. Par exemple, "a" permet de faire pivoter le cadre autour de son axe vertical vers la gauche, et "e" sur le même axe mais vers la droite. De cette manière l'utilisateur peut observer avec attention le contenu du cadre.
		
		Pour replacer le cadre dans la ruche, l'utilisateur doit l'approcher de l'emplacement auquel il souhaite le mettre, puis faire un clic gauche. Une fois assez proche, l'application placera un cadre "fantôme" rouge, permettant à l'utilisateur de savoir qu'en lâchant le cadre, ce-dernier ira prendre la place du cadre fantôme. En effet, il est assez compliqué de replacer le cadre correctement une fois l'avoir fait pivoter dans les 3 directions, c'est pourquoi nous avons mis en place cette aide. Il est ainsi possible de replacer un cadre précisément à l'emplacement que l'on souhaite. Lâcher le cadre alors que le cadre fantôme n'est pas apparu le laissera flotter là où il a été lâché. La commande signalant au serveur la pose du cadre ne se fait que lorsque celui-ci est replacé dans la ruche.
		
		
		
	\section{Interaction Immersive}
	\label{immersionSansTangibles}
		Nous avons ensuite travaillé sur un autre mode d'interactions, prenant place dans un environnement immersif. L'utilisateur utilise alors un casque de réalité virtuelle et les manettes associées, afin de visualiser et d'interagir avec l'environnement 3D.
		
		 L'utilisateur se déplace dans l'application interactive en se déplaçant physiquement. L'interaction avec les cadres se fait via les manettes. L'utilisateur va placer ses mains (et donc ses manettes), de tel manière à ce que la représentation de ses manettes dans l'environnement se superposent à la partie supérieure du cadre. Il peut alors maintenir appuyé un bouton par manette afin de saisir le cadre, qui suivra désormais les mouvements de ses mains. Replacer un cadre dans la ruche est assez proche de la version Clavier Souris. L'utilisateur doit placer le cadre suffisamment proche de l'emplacement où il souhaite l'insérer, et le lâcher. Le cadre ira alors se placer automatiquement à l'emplacement libre le plus proche. Les autres fonctionnalités d'interactions sont obtenues via différents boutons sur les manettes.
		
		Les communications réseaux de cette version ont été coupée, l'application lit directement des \textit{logs} de simulation déjà générés. Il n'est donc pas possible d'interagir directement avec la simulation. La manipulation des cadres se fait à des fins purement pédagogiques et la lecture des \textit{logs} permet la visualisation de données de la simulation. Cette version de l'application interactive a été développée dans le cadre d'un stage de M2 dans le but de servir de support à l'évaluation, dont nous parlerons dans le \textit{Chapitre VII}.
		
		
	\section{Interaction Naturelle et Immersive}
	
	Ce mode d'interaction est une des contributions principales de ces travaux. Afin de proposer des moyens d'interactions naturels avec la simulation multi-agents, nous proposons ici d'utiliser des interacteurs tangibles. Ainsi, l'utilisateur portera un casque de réalité virtuelle, l'immergeant dans l'environnement 3D.

		\subsection{Le Cadre et la Ruche Traqués}
		Nous plaçons dans l'environnement physique de l'utilisateur une ruche bien réelle, contenant un unique cadre spécial, servant de manette. Ce cadre et la ruche sont "traqués" : via quelques cibles infra rouges placés dessus (et une série de caméra réparties dans la salle), leurs positions et rotations sont en permanence connues de l'ordinateur. Nous pouvons ainsi superposer la ruche virtuelle présente dans l'application interactive à la ruche physique, après de rapides calibrations. De la même manière, le cadre traqué possède une représentation virtuelle superposée, ce qui permet à l'utilisateur de saisir le cadre physique en ne voyant que le cadre virtuel. Ce cadre "manette" est facilement différentiable des cadres virtuels de la simulation : il est creux et blanc, là où les autres présentent des alvéoles et sont couleur bois. Dans cette première itération, l'utilisateur à tout de même besoin d'une manette pour réaliser ses interactions.
		
		\subsection{La Manette}		
		Afin de ne pas trop gêner l'utilisateur lors de ses manipulations, les différentes interactions se trouvent toutes sur une seule manette, permettant de tenir le cadre physique de l'autre main. Afin de faire avec le nombre limité de boutons que propose la manette, nous avons mis en place un système de mode, permettant de varier les effets de mêmes boutons. Cette méthode permettra d'ajouter de nouveaux modes par la suite au besoin. 		
		Le bouton principal de la manette que nous utilisons, la manette du \textit{HTC Vive}, est aussi une surface tactile. Ainsi, nous pouvons détecter la position du doigt de l'utilisateur sur le bouton lors de l'appui. Ceci nous permet de diviser ce bouton en différents cadrans (ou sections), et ainsi plusieurs boutons virtuels. Nous pouvons ainsi utiliser un nombre très limité de boutons de la manette, permettant aux utilisateurs de se familiariser rapidement avec la manette et ses fonctionnalités. 
		
		Trois modes ont été implémenté pour cette itération :		
		\begin{enumerate}
			\item Mode Cadre : le bouton principal permet de réaliser une division. Le bouton secondaire permet de saisir et de lâcher les cadres virtuels à l'aide du cadre physique.
			\item Mode Temps : le bouton principal divisé en plusieurs cadrans permet d'accélérer la simulation pour différents temps définis.
			\item Mode Visualisation : nous parlerons de ce mode dans la Section \ref{Manip3D}.
		\end{enumerate}
		
		La Figure \ref{ManetteVR} illustre la vision de la manette par l'utilisateur dans chacun de ces trois modes. On y observe notamment le bouton principal divisé en quatre cadrans, différenciés par des couleurs tranchées. Un autre bouton de la manette, au dessus du bouton principal, permet de faire défiler les modes les uns à la suite des autres. Un texte flottant au dessus de la manette permet à l'utilisateur de rapidement identifier le mode courant. De plus, des textes et couleurs sont plaquées sur la manette, s'adaptant aux différents modes afin de toujours refléter la fonction du bouton. Le bouton principal ainsi que le bouton de mode sont utilisés avec le pouce, le bouton secondaire est une gâchette généralement actionnée avec l'index.
		
		\begin{figure}
		\centering
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVR.JPG}
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVRFrame.JPG}
		\includegraphics[height=.23\textheight]{Pictures/ScreenShots/ManetteVRGraph.JPG}
		\caption[Manettes vue par l'utilisateur, respectivement en mode Temps, Cadre et Visualisation.]{Manettes vue par l'utilisateur, respectivement en modes Temps, Cadre et Visualisation. On observe le bouton principal divisé en quatre cadrans, transformant ce bouton unique en quatre boutons "virtuels".}
		\label{ManetteVR}
		\end{figure}
		
		\subsection{Manipulation des Cadres}		
		Afin de saisir un cadre, l'utilisateur vient superposer le cadre physique avec un des cadres virtuels présent dans la ruche. Ensuite, appuyer sur le bouton secondaire va venir plaquer le cadre virtuel ainsi sélectionné sur le cadre réel. L'utilisateur manipule désormais directement le cadre virtuel tiré de la simulation via son cadre physique. Il peut donc l'orienter facilement et l'observer de toute part de manière naturelle, comme nous le ferions avec n'importe quel objet bien réel. Un nouvel appui du bouton secondaire fera lâcher le cadre virtuel qui restera à flotter dans l'air. Si le cadre virtuel est lâché alors que le cadre manette est superposé à un emplacement vide dans la ruche, alors le cadre virtuel y est inséré et le serveur est prévenu.
		
		Pour réaliser une division, l'utilisateur a deux possibilités, matérialisées sur deux des quatre cadrans du bouton principal. La division consiste à séparer la ruche en deux, et se concentrer ensuite sur l'une de ces deux nouvelles colonies. Une fois que l'utilisateur à sorti une certaine quantité de cadres, il peut choisir de réaliser la division. Les cadres à l'intérieur de la ruche formeront une nouvelle colonie, ainsi que tous ceux qui sont à l'extérieur. L'utilisateur doit donc choisir quelle ruche il désire suivre, l'ancienne ou la nouvelle. La manette propose ainsi de "Jeter" les cadres présents dans la ruche initiale, ou de les "Garder" et de jeter les autres, comme illustré dans la Figure \ref{ManetteVR}.

		\paragraph{}		
		Pour une itération future de ce moyen d'interaction, nous avons pensé équiper le cadre physique d'un bouton, afin de pouvoir saisir et lâcher les cadres virtuels sans avoir besoin de la manette. Ce bouton remplacerait alors le bouton secondaire de la manette, la gâchette. Ceci permet de manipuler les cadres à deux mains, comme le font les apiculteurs. En effet, si les cadres vides et sans cire sont légers, les cadres bâtis (remplis d'alvéoles de cire) et plein de miel peuvent facilement peser quelques kilogrammes.
		
		Une autre possibilité d'amélioration pour cette interaction est de diminuer la taille des cibles infra-rouge. En effet, leur taille nous empêche de traquer plusieurs cadres sans que ceux-ci ne se gênent pour ensuite rentrer dans la ruche. De plus petits capteurs permettraient de traquer l'ensemble des cadres de la ruche, rendant la manipulation encore plus naturelle. Il sera alors nécessaire de détecter lorsque l'utilisateur saisi et lâche un cadre via les mouvements et positions des cadres.
		
		Quelques prototypes ont été réalisés de ces deux propositions, mais beaucoup de travail reste à faire.
		
		Frapper un cadre se fait par l'appui d'un autre bouton sur la manette. En effet, nos premiers essais de détection de frappe sur le cadre via le \textit{tracking} (changements brusques de vitesses) nous donnait des comportements trop imprévisibles. En effet, les données sont bruités et le coup sec que les apiculteurs donnent au cadre pour en faire tomber les abeilles est difficile à isoler. Nous pensons intégrer une centrale inertielle au cadre afin de ne pas détecter le choc via les caméra, mais directement depuis le cadre. Il serait peut être possible d'utiliser les données du \textit{tracking} en y appliquant un traitement adapté.
		
		\subsection{Manipulation du Temps}
		
		Pour manipuler le temps, le bouton principal est divisé en quatre cadrans. Trois de ceux-ci présentent différents temps d'accélération prédéfinis, 7 jours, 1 jour et 5 heures, visibles sur la Figure \ref{ManetteVR} à gauche. L'intervalle de 7 jours correspond en général à la fréquence des visites de ruches de la part d'apiculteurs, les autres ont été choisi arbitrairement. Le troisième cadran "Stop" permet à l'utilisateur d'interrompre l'avance rapide, demandant au serveur de repasser en temps réel sans attendre d'avoir fini la précédente requête d'accélération. Envoyer une nouvelle requête efface la précédente, les durées d'accélération ne s'additionnent pas. Par exemple, le bouton Stop demande en réalité au serveur une avance rapide de zéro pas de temps, ce qui a pour effet de stopper toute avance rapide alors engagée.
		
	\section{Visualisation : Graph3D sur l'état interne de la colonie}
		Dans le but d'offrir une visualisation mettant en valeur les mécanismes de l'auto-organisation au sein de la colonie d'abeilles, nous proposons d'utiliser un graphique en 3 dimensions (sur 3 axes), que nous avons pour l'instant simplement surnommé le "\textit{Graph3D}".
		
		\subsection{Fonctionnement du Graph3D}
		
		Pour reprendre simplement ce que nous avons vu dans le \textit{Chapitre Contexte} ainsi que dans le \textit{Chapitre III}, les abeilles, via leurs phéromones, viennent altérer leur âge physiologique. Cette altération devient visible car cet âge physiologique se décorrèle de leur âge réel. Nous proposons donc de placer chacune de ses données sur un axe, et de positionner ensuite chaque abeille de la simulation en un point du volume ainsi formé. La Figure \ref{Graph3D} illustre le Graph3D dans le cas d'une colonie classique respectant le polyéthisme d'âge, et dans le cas théorique d'une colonie peu après une division. Dans le premier cas, Figure \ref{Graph3DStd}, l'âge physiologique et l'âge réel sont proches, les abeilles âgées butinent et les jeunes s'occupent du couvain. Dans le cas de la division, l'interruption de la ponte lié à la perte de la reine provoque un grand déséquilibre dans les répartitions des âges de la colonie. Nous nous attendons ainsi à observer de jeunes abeilles partir butiner plus tôt, c'est pour ceci que nous observons sur la Figure \ref{Graph3DDiv} des cubes jaunes (physiologie de butineuse) dans la moitié gauche du Graph3D, contenant les jeunes abeilles.
		
		Le troisième axe, celui dédié aux échanges de phéromones, permet comparativement de comprendre pourquoi certaines abeilles partent butiner plus tôt que d'autres. Les abeilles partant butiner plus tôt sont celles qui ont le moins échangé de phéromones, censées les faire rester physiologiquement jeunes. Ainsi, plus une abeilles est loin sur l'axe des phéromones échangées, plus elle aura un âge physiologique faible. Cette donnée est obtenu en additionnant l'ensemble des échanges de chaque abeille avec les autres, en valeur absolue. Ainsi, donner une quantité de phéromone, ou recevoir cette même quantité aura le même impact sur cette valeur. Pour mieux représenter la réalité, cette somme est multipliée à chaque pas de temps par un coefficient légèrement inférieur à 1, afin de minimiser progressivement l'impact d'échanges lointains.
		
		Les abeilles sont positionnées dans le Graph3D en utilisant un nuage de points semblable à ceux utilisés pour les placer sur les cadres. Nous y retrouvons, pour faciliter la lecture, la redondance de l'information de l'âge physiologique sous la forme de la couleur des abeilles. Toutes les abeilles au delà de $\frac{1}{2}$ sur l'axe de l'âge physiologique sera dessinée jaune, les autres en rouge.
		
	\begin{figure}
	\centering
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.8\textwidth]{Pictures/Graphs/Graph3DStd.JPG}
	\caption{}
	\label{Graph3DStd}	
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=.8\textwidth]{Pictures/Graphs/Graph3DDiv.JPG}
	\caption{}
	\label{Graph3DDiv}
	\end{subfigure}
	
	\caption[Notre \textit{Graph3D} et ses trois axes.]{Notre \textit{Graph3D} et ses trois axes. Chaque cube représente une abeille. La couleur du cube est une redondance de l'âge physiologique, rouge lorsqu'il est inférieur à $\frac{1}{2}$, jaune sinon. Une cube plus petit représente un cube plus loin sur l'axe de la profondeur, donc ici une abeille qui aurai échangé plus de phéromones. Dans le cas d'une colonie standard, nous nous attendons à trouver le Graph3D sous la forme (a), dans le cas d'une division nous nous attendons plutôt à la forme (b).}	
	\label{Graph3D}
	\end{figure}
	
	\subsection{Manipulation du Graph3D}
	\label{Manip3D}
	
		\subsubsection{Clavier Souris}
		Dans la version Clavier Souris, le graph 3D est manipulé en utilisant trois positions prédéfinies. Les touches "1", "2" et "3" sont chacune associée à une rotation du Graph3D, qui viendra à l'appui se placer devant l'utilisateur dans la rotation souhaité. Ensuite l'utilisateur peut naviguer autour du graphique afin de mieux en saisir la profondeur. En effet, sur un écran le Graph3D est relativement difficile à lire, du fait de la projection 2D. Le Graph3D a été pensé pour fonctionner en environnement immersif.
		
		\subsubsection{Environnement Immersif et Manette}
		Équipé d'une casque de réalité virtuelle, l'utilisateur peut manipuler le graphique à l'aide d'une manette. De la même manière que la version Clavier Souris, le Graph3D possède des ancres de rotation, et appuyer sur un des quatre cadrans du bouton principal sélectionne l'une de ses rotations. Lors de la sélection, le Graph3D vient se placer juste au dessus de la manette, dans la rotation souhaitée. L'utilisateur peut aussi appuyer sur le bouton secondaire de la manette afin de "saisir" le graphique. Une fois saisi, le graphique est "fixé" sur la manette, ainsi les mouvements de poignets de l'utilisateur déplaceront le graphique, en position comme en rotation. Cette méthode de manipulation, aidée par le casque de réalité virtuelle, permet de mieux ressentir les trois axes du Graph3D. De plus, cette dernière méthode de manipulation permet une interaction plus naturelle avec l'objet de visualisation, en effet, manipuler le graphique se fait comme nous manipulons des objets réels.
		
	
	
			
	\section*{Conclusion}
	Dans ce chapitre nous avons présenté notre architecture logicielle. La séparation complète du simulateur et de l'application de visualisation et d'interaction nous offre souplesse et modularité. Nous avons décrit les échanges réseaux de ces deux parties, ainsi que les traitements qu'ils déclenchent. Nous avons passé en revue les différentes modélisations et représentations 3D de l'application, dont l'utilisation de nuages de points pour représenter les abeilles. Nous avons ensuite décrit les différents moyens d'interactions avec la simulation, depuis l'application interactive, dans différentes versions, pour différents supports, dont notre proposition de l'utilisation d'interacteurs tangibles pour des interactions naturelles.
	Nous avons ensuite présenté notre proposition de visualisation des mécanismes régissant la répartition des tâches au sein de la colonie, sous la forme d'un graphique en trois dimension, présentant l'état interne de chaque abeille de la simulation, dans un nuage de points.
	
	 Nous allons dans le chapitre suivant évaluer certaines de ces propositions, en décrivant l'expérimentation que nous avons mis en place, puis discuter des résultats obtenus et des perspectives qu'ils offrent.
	